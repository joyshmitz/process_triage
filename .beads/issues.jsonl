{"id":"process_triage-097","title":"Self-Update Mechanism","description":"## Overview\nAdd a secure, robust self-update mechanism to pt, following the patterns established in repo_updater and giil.\n\n## Current State\n- pt has NO self-update capability\n- Users must manually check for updates\n- No VERSION file for version tracking\n- No infrastructure for update verification\n\n## Target State\nA complete self-update system with:\n1. **Version detection** via HTTP redirect (no GitHub API needed)\n2. **Checksum verification** for security\n3. **Bash syntax validation** before replacement\n4. **Atomic file replacement** to prevent corruption\n5. **Permission pre-checking** for fail-fast behavior\n\n## Why No GitHub API?\nFrom repo_updater's design:\n- Avoids rate limiting issues\n- Works through corporate proxies that block API\n- Simpler implementation with fewer failure modes\n- Uses redirect probing: curl follows `/releases/latest` → extracts version from final URL\n\n## Security Model\n1. Download checksums.txt from GitHub release\n2. Verify downloaded script matches expected hash\n3. Validate bash syntax with `bash -n`\n4. Only then replace the running script\n\n## Implementation Pattern\n```bash\n# Get latest version without API\nlatest_url=$(curl -fsSL -o /dev/null -w '%{url_effective}' \\\n    'https://github.com/USER/REPO/releases/latest')\nlatest_version=${latest_url##*/v}  # Extract version from URL\n\n# Verify checksum\nexpected=$(curl -fsSL \".../checksums.sha256\" | grep ' pt$' | cut -d' ' -f1)\nactual=$(sha256sum \"$temp_file\" | cut -d' ' -f1)\n[[ \"$expected\" == \"$actual\" ]] || die 'Checksum mismatch'\n\n# Validate syntax before replacing\nbash -n \"$temp_file\" || die 'Downloaded file is not valid bash'\n\n# Atomic replacement\nmv \"$temp_file\" \"$script_path\"\n```\n\n## CLI Integration\n- `pt update` - Check and install updates\n- `pt update --check` - Check only, don't install\n- `pt --version` - Show current version (already exists)\n\n## Success Criteria\n- [ ] VERSION file exists and is single source of truth\n- [ ] Update check works without GitHub API\n- [ ] Checksums are verified before installation\n- [ ] Syntax is validated before replacement\n- [ ] Atomic replacement prevents corruption\n- [ ] Clear messaging for all outcomes","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:31:19.148532987-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:31:19.148532987-05:00"}
{"id":"process_triage-0nk","title":"Add unit tests for each CLI command","description":"## Purpose\nCreate systematic unit tests for each pt CLI command to verify correct behavior, error handling, and edge cases.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## Depends On\n- Test helper with mock injection (process_triage-h2y)\n\n## Test Scenarios\n\n### test/test_commands.bats\n\n```bash\n#!/usr/bin/env bats\n\nload 'test_helper/common'\n\nsetup() {\n    setup_test_env\n    test_start \"$BATS_TEST_NAME\" \"CLI command test\"\n    export PT_SCRIPT=\"${BATS_TEST_DIRNAME}/../pt\"\n}\n\nteardown() {\n    test_end \"$BATS_TEST_NAME\" \"${BATS_TEST_COMPLETED:-fail}\"\n    restore_path\n    teardown_test_env\n}\n\n#==============================================================================\n# HELP COMMAND TESTS\n#==============================================================================\n\n@test \"Command: pt help shows usage information\" {\n    test_info \"Running: pt help\"\n    run \"$PT_SCRIPT\" help\n    \n    assert_equals \"0\" \"$status\" \"help should succeed\"\n    \n    test_info \"Verifying help content\"\n    assert_contains \"$output\" \"Process Triage\" \"Should show tool name\"\n    assert_contains \"$output\" \"scan\" \"Should document scan\"\n    assert_contains \"$output\" \"history\" \"Should document history\"\n    assert_contains \"$output\" \"clear\" \"Should document clear\"\n    assert_contains \"$output\" \"help\" \"Should document help\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt --help is alias for help\" {\n    test_info \"Running: pt --help\"\n    run \"$PT_SCRIPT\" --help\n    \n    assert_equals \"0\" \"$status\" \"--help should succeed\"\n    assert_contains \"$output\" \"Process Triage\" \"Should show same content as help\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt -h is alias for help\" {\n    test_info \"Running: pt -h\"\n    run \"$PT_SCRIPT\" -h\n    \n    assert_equals \"0\" \"$status\" \"-h should succeed\"\n    assert_contains \"$output\" \"Process Triage\" \"Should show same content as help\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# VERSION COMMAND TESTS\n#==============================================================================\n\n@test \"Command: pt --version shows version\" {\n    test_info \"Running: pt --version\"\n    run \"$PT_SCRIPT\" --version\n    \n    assert_equals \"0\" \"$status\" \"version should succeed\"\n    assert_contains \"$output\" \"pt version\" \"Should show version prefix\"\n    \n    # Verify semver format\n    test_info \"Checking version format\"\n    [[ \"$output\" =~ [0-9]+\\.[0-9]+\\.[0-9]+ ]]\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt -v is alias for version\" {\n    test_info \"Running: pt -v\"\n    run \"$PT_SCRIPT\" -v\n    \n    assert_equals \"0\" \"$status\" \"-v should succeed\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt version is alias for --version\" {\n    test_info \"Running: pt version\"\n    run \"$PT_SCRIPT\" version\n    \n    assert_equals \"0\" \"$status\" \"version subcommand should succeed\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# SCAN COMMAND TESTS\n#==============================================================================\n\n@test \"Command: pt scan succeeds with no processes\" {\n    test_info \"Setting up: empty process list\"\n    \n    create_mock_ps \"\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    # Should succeed even with no candidates\n    assert_equals \"0\" \"$status\" \"scan should succeed\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt scan shows candidates when found\" {\n    test_info \"Setting up: mock process list\"\n    \n    create_mock_ps \"$(mock_ps_with_stuck_test 7200)\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    assert_equals \"0\" \"$status\" \"scan should succeed\"\n    \n    # Should show the process\n    test_info \"Verifying output contains process info\"\n    # Output format depends on implementation\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt scan respects NO_COLOR\" {\n    test_info \"Setting up: NO_COLOR environment\"\n    \n    export NO_COLOR=1\n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan with NO_COLOR=1\"\n    run \"$PT_SCRIPT\" scan\n    \n    # Output should NOT contain ANSI escape codes\n    assert_not_contains \"$output\" $'\\033' \"Should not contain escape codes\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# HISTORY COMMAND TESTS\n#==============================================================================\n\n@test \"Command: pt history with empty decisions\" {\n    test_info \"Setting up: empty decision file\"\n    \n    echo '{}' \u003e \"${CONFIG_DIR}/decisions.json\"\n    export PROCESS_TRIAGE_CONFIG=\"$CONFIG_DIR\"\n    \n    test_info \"Running: pt history\"\n    run \"$PT_SCRIPT\" history\n    \n    assert_equals \"0\" \"$status\" \"history should succeed\"\n    \n    # Should indicate no history or show empty\n    test_info \"Output: $output\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt history shows saved decisions\" {\n    skip_if_no_jq\n    \n    test_info \"Setting up: populated decision file\"\n    \n    cat \u003e \"${CONFIG_DIR}/decisions.json\" \u003c\u003c 'EOF'\n{\n    \"bun test --watch\": \"kill\",\n    \"gunicorn\": \"spare\",\n    \"next dev\": \"kill\"\n}\nEOF\n    export PROCESS_TRIAGE_CONFIG=\"$CONFIG_DIR\"\n    \n    test_info \"Running: pt history\"\n    run \"$PT_SCRIPT\" history\n    \n    assert_equals \"0\" \"$status\" \"history should succeed\"\n    \n    # Should show the patterns\n    assert_contains \"$output\" \"bun test\" \"Should show bun test pattern\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# CLEAR COMMAND TESTS\n#==============================================================================\n\n@test \"Command: pt clear removes decisions (non-interactive)\" {\n    skip_if_no_jq\n    \n    test_info \"Setting up: decisions to clear\"\n    \n    echo '{\"pattern1\": \"kill\"}' \u003e \"${CONFIG_DIR}/decisions.json\"\n    export PROCESS_TRIAGE_CONFIG=\"$CONFIG_DIR\"\n    \n    # For non-interactive, we need to handle confirmation\n    # This depends on implementation\n    \n    test_info \"Running: pt clear\"\n    # May need to pipe 'y' for confirmation\n    echo 'y' | \"$PT_SCRIPT\" clear 2\u003e/dev/null || run \"$PT_SCRIPT\" clear --force 2\u003e/dev/null || true\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# ERROR HANDLING TESTS\n#==============================================================================\n\n@test \"Command: unknown command shows error\" {\n    test_info \"Running: pt unknowncommand\"\n    run \"$PT_SCRIPT\" unknowncommand\n    \n    # Should fail\n    [[ $status -ne 0 ]]\n    \n    # Should show helpful message\n    assert_contains \"$output\" \"Unknown\\|unknown\\|help\" \"Should mention unknown or help\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: multiple unknown commands all fail\" {\n    for cmd in foo bar baz notacommand; do\n        test_info \"Testing unknown command: $cmd\"\n        run \"$PT_SCRIPT\" \"$cmd\"\n        [[ $status -ne 0 ]]\n    done\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# DEFAULT COMMAND TESTS\n#==============================================================================\n\n@test \"Command: pt with no args runs default (run)\" {\n    test_info \"Setting up: mock for default command\"\n    \n    # Default command should be 'run' (interactive mode)\n    # In test, this might need special handling\n    \n    export CI=true  # Might affect behavior\n    create_mock_ps \"\"\n    use_mock_bin\n    \n    test_info \"Running: pt (no arguments)\"\n    # This might prompt for input in interactive mode\n    # Run with timeout or specific test handling\n    timeout 5 \"$PT_SCRIPT\" 2\u003e/dev/null || true\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Command: pt run is explicit default\" {\n    test_info \"Running: pt run\"\n    \n    export CI=true\n    create_mock_ps \"\"\n    use_mock_bin\n    \n    timeout 5 \"$PT_SCRIPT\" run 2\u003e/dev/null || true\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# ENVIRONMENT VARIABLE TESTS\n#==============================================================================\n\n@test \"Command: respects PT_DEBUG=1\" {\n    test_info \"Setting up: PT_DEBUG=1\"\n    \n    export PT_DEBUG=1\n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan with debug\"\n    run \"$PT_SCRIPT\" scan\n    \n    # Debug output should appear (depends on implementation)\n    test_info \"Output length: ${#output}\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n```\n\n## Success Criteria\n- [ ] help command and aliases tested\n- [ ] version command and aliases tested\n- [ ] scan command tested (empty, with results, NO_COLOR)\n- [ ] history command tested (empty, populated)\n- [ ] clear command tested\n- [ ] Unknown commands tested\n- [ ] Default command tested\n- [ ] Environment variables tested\n- [ ] All tests have detailed logging","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:49:13.792264809-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:49:13.792264809-05:00","dependencies":[{"issue_id":"process_triage-0nk","depends_on_id":"process_triage-h2y","type":"blocks","created_at":"2026-01-14T22:50:31.165127826-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-18z","title":"Add TTY detection and NO_COLOR support","description":"## Purpose\nAdd proper terminal detection to ensure colors/styling only appear when appropriate, following accessibility standards.\n\n## Parent Epic\nConsole Output Styling Enhancement (process_triage-y8e)\n\n## Current State\nThe pt script uses colors unconditionally via gum. No fallback exists when:\n- Output is piped (`pt scan | grep something`)\n- Running in CI environment\n- User has NO_COLOR set (accessibility)\n- Terminal doesn't support colors\n\n## Implementation\n\n### 1. Add Detection Variables (near top of script)\n```bash\n#------------------------------------------------------------------------------\n# Terminal detection\n#------------------------------------------------------------------------------\n\n# Detect if we're in an interactive terminal\nIS_TTY=false\n[[ -t 1 ]] \u0026\u0026 IS_TTY=true\n\n# Detect if colors should be disabled\n# NO_COLOR is a standard: https://no-color.org/\nUSE_COLOR=true\nif [[ \"$IS_TTY\" \\!= \"true\" ]] || [[ -n \"${NO_COLOR:-}\" ]]; then\n    USE_COLOR=false\nfi\n\n# Detect CI environment\nIS_CI=false\n[[ -n \"${CI:-}\" ]] \u0026\u0026 IS_CI=true\n```\n\n### 2. Conditional Color Definitions\n```bash\n#------------------------------------------------------------------------------\n# ANSI color codes (disabled if NO_COLOR or non-TTY)\n#------------------------------------------------------------------------------\n\nif [[ \"$USE_COLOR\" == \"true\" ]]; then\n    RED='\\033[0;31m'\n    GREEN='\\033[0;32m'\n    YELLOW='\\033[1;33m'\n    BLUE='\\033[0;34m'\n    CYAN='\\033[0;36m'\n    MAGENTA='\\033[0;35m'\n    BOLD='\\033[1m'\n    DIM='\\033[2m'\n    RESET='\\033[0m'\nelse\n    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' MAGENTA=''\n    BOLD='' DIM='' RESET=''\nfi\n```\n\n### 3. Update Gum Availability Check\n```bash\n# Gum should only be used in interactive TTY, not in CI\nGUM_AVAILABLE=false\nif [[ \"$IS_TTY\" == \"true\" ]] \u0026\u0026 [[ \"$IS_CI\" \\!= \"true\" ]] \u0026\u0026 command -v gum \u0026\u003e/dev/null; then\n    GUM_AVAILABLE=true\nfi\n```\n\n## Testing\n```bash\n# Should show colors\npt scan\n\n# Should NOT show colors\npt scan | cat\nNO_COLOR=1 pt scan\nCI=true pt scan\n```\n\n## NO_COLOR Standard\nFrom https://no-color.org/:\n\u003e Command-line software which adds ANSI color to its output by default should check for the presence of a NO_COLOR environment variable that, when present (regardless of its value), prevents the addition of ANSI color.\n\n## Success Criteria\n- [ ] Colors appear in interactive terminal\n- [ ] Colors disabled when piped\n- [ ] Colors disabled when NO_COLOR is set\n- [ ] Colors disabled in CI environments\n- [ ] Gum only used in interactive TTY","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:33:31.544024152-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:33:31.544024152-05:00"}
{"id":"process_triage-1zu","title":"Add checksum verification option to installer","description":"## Purpose\nAdd optional checksum verification to the installer, enabled via VERIFY=1 environment variable.\n\n## Parent Epic\nInstallation Infrastructure (process_triage-n0r)\n\n## Depends On\n- Add cross-platform mktemp and download functions\n- Release automation generates checksums (process_triage-aip)\n\n## Usage\n\n```bash\n# Without verification (default - for simplicity)\ncurl -fsSL .../install.sh | bash\n\n# With verification (security-conscious users)\nVERIFY=1 curl -fsSL .../install.sh | bash\n```\n\n## Implementation\n\n```bash\nverify_download() {\n    local file=\"$1\"\n    local version=\"$2\"\n    \n    if [[ \"${VERIFY:-}\" != \"1\" ]]; then\n        return 0  # Verification not requested\n    fi\n    \n    log_step \"Verifying checksum...\"\n    \n    # Download expected checksum\n    local checksum_url=\"${RELEASES_URL}/download/v${version}/pt.sha256\"\n    local expected\n    \n    expected=$(curl -fsSL --connect-timeout 5 \"$checksum_url\" 2\u003e/dev/null) || {\n        log_error \"Could not download checksum file\"\n        log_error \"URL: $checksum_url\"\n        log_error \"\"\n        log_error \"If this is a new release, checksums may not be available yet.\"\n        log_error \"Try again in a few minutes, or install without verification:\"\n        log_error \"  curl -fsSL .../install.sh | bash\"\n        return 1\n    }\n    \n    # Extract hash (format: \"hash  filename\" or just \"hash\")\n    expected=\"${expected%% *}\"\n    \n    # Compute actual\n    local actual\n    actual=$(sha256_file \"$file\") || {\n        log_warn \"Could not compute checksum (no SHA256 tool)\"\n        log_warn \"Skipping verification\"\n        return 0\n    }\n    \n    # Compare\n    if [[ \"$expected\" == \"$actual\" ]]; then\n        log_success \"Checksum verified: ${actual:0:16}...\"\n        return 0\n    else\n        log_error \"Checksum mismatch!\"\n        log_error \"Expected: $expected\"\n        log_error \"Actual:   $actual\"\n        log_error \"\"\n        log_error \"The downloaded file may be corrupted or tampered with.\"\n        log_error \"Please report this issue if it persists.\"\n        return 1\n    fi\n}\n```\n\n## Integration\n\n```bash\nmain() {\n    # ... download pt to temp file ...\n    \n    # Verify if requested\n    if ! verify_download \"$temp_file\" \"$version\"; then\n        log_error \"Installation aborted due to verification failure\"\n        exit 1\n    fi\n    \n    # ... continue with installation ...\n}\n```\n\n## Manual Verification Instructions (for README)\n\n```bash\n# Download pt\ncurl -fsSL https://github.com/.../releases/download/v1.0.0/pt -o pt\n\n# Download checksum\ncurl -fsSL https://github.com/.../releases/download/v1.0.0/pt.sha256 -o pt.sha256\n\n# Verify\nsha256sum -c pt.sha256\n# or on macOS:\nshasum -a 256 -c pt.sha256\n```\n\n## Success Criteria\n- [ ] VERIFY=1 enables verification\n- [ ] Without VERIFY, install proceeds without check\n- [ ] Clear error if checksum file unavailable\n- [ ] Clear error on mismatch\n- [ ] Works on Linux (sha256sum) and macOS (shasum)\n- [ ] Graceful degradation if no SHA256 tool","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:36:33.838790733-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:36:33.838790733-05:00","dependencies":[{"issue_id":"process_triage-1zu","depends_on_id":"process_triage-c57","type":"blocks","created_at":"2026-01-14T22:40:45.58810567-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-3v6","title":"Add bash syntax validation before replacement","description":"## Purpose\nValidate that downloaded scripts are valid bash before replacing the running script, preventing bricking.\n\n## Parent Epic\nSelf-Update Mechanism (process_triage-097)\n\n## Depends On\n- Add checksum verification for updates\n\n## Why This Matters\nIf a corrupted or truncated file is installed:\n1. User runs `pt` → syntax error → script doesn't work\n2. User can't use `pt update` to fix it (script is broken)\n3. Manual intervention required\n\n## Implementation\n\n### Syntax Validation Function\n```bash\nvalidate_bash_syntax() {\n    local file=\"$1\"\n    \n    # bash -n parses but doesn't execute\n    # Returns 0 if valid, non-zero if syntax errors\n    if \\! bash -n \"$file\" 2\u003e/dev/null; then\n        log_error \"Downloaded file is not valid bash\"\n        \n        # Show the actual error for debugging\n        log_debug \"Syntax check output:\"\n        bash -n \"$file\" 2\u003e\u00261 | while read -r line; do\n            log_debug \"  $line\"\n        done\n        \n        return 1\n    fi\n    \n    log_debug \"Bash syntax validation passed\"\n    return 0\n}\n```\n\n### Additional Sanity Checks\n```bash\nvalidate_script() {\n    local file=\"$1\"\n    \n    # 1. Check it's not empty\n    if [[ \\! -s \"$file\" ]]; then\n        log_error \"Downloaded file is empty\"\n        return 1\n    fi\n    \n    # 2. Check it starts with shebang\n    local first_line\n    first_line=$(head -n1 \"$file\")\n    if [[ \"$first_line\" \\!= \"#\\!/\"* ]]; then\n        log_error \"Downloaded file doesn't start with shebang\"\n        return 1\n    fi\n    \n    # 3. Check bash syntax\n    if \\! validate_bash_syntax \"$file\"; then\n        return 1\n    fi\n    \n    # 4. Check it contains expected content (anti-tampering)\n    if \\! grep -q 'VERSION=' \"$file\"; then\n        log_error \"Downloaded file missing VERSION constant\"\n        return 1\n    fi\n    \n    if \\! grep -q 'Process Triage' \"$file\"; then\n        log_error \"Downloaded file missing expected identifier\"\n        return 1\n    fi\n    \n    log_success \"Script validation passed\"\n    return 0\n}\n```\n\n### Integration with Update Flow\n```bash\ndo_update() {\n    local version=\"$1\"\n    local temp_file=\"...\"\n    \n    # ... download ...\n    \n    # Verify checksum\n    verify_checksum \"$temp_file\" \"$version\" || return 1\n    \n    # Validate script\n    validate_script \"$temp_file\" || {\n        log_error \"Script validation failed, aborting update\"\n        return 1\n    }\n    \n    # Now safe to replace\n    # ...\n}\n```\n\n## What bash -n Catches\n- Syntax errors (unclosed quotes, brackets)\n- Parse errors (invalid commands in wrong places)\n- Heredoc issues (unterminated heredocs)\n\n## What bash -n Doesn't Catch\n- Runtime errors (undefined variables with set -u)\n- Logic errors\n- Missing dependencies\n\nThat's why we also check for expected content markers.\n\n## Success Criteria\n- [ ] Syntax validation with bash -n\n- [ ] Empty file detection\n- [ ] Shebang verification\n- [ ] Expected content markers checked\n- [ ] Clear error messages on failure\n- [ ] Debug output shows actual syntax errors","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:35:05.792231414-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:35:05.792231414-05:00","dependencies":[{"issue_id":"process_triage-3v6","depends_on_id":"process_triage-nk1","type":"blocks","created_at":"2026-01-14T22:52:20.687792331-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-45o","title":"Add pattern normalization tests","description":"## Purpose\nAdd comprehensive tests for the pattern normalization algorithm that creates stable process fingerprints.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## Why Pattern Normalization Matters\nThe decision memory system relies on normalized patterns to match similar processes across sessions:\n- `bun test --port 3000` and `bun test --port 4000` should match\n- `node /tmp/abc123/server.js` and `node /tmp/xyz789/server.js` should match\n- PIDs, UUIDs, ports should be generalized\n\n## Implementation\n\n### test/test_patterns.bats\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    export TEST_MODE=1\n    source \"${BATS_TEST_DIRNAME}/../pt\" 2\u003e/dev/null || true\n}\n\n#------------------------------------------------------------------------------\n# PID removal tests\n#------------------------------------------------------------------------------\n\n@test \"normalize_pattern: removes 5+ digit PIDs\" {\n    local result\n    result=$(normalize_pattern \"node 12345 server.js\")\n    \n    [[ \"$result\" != *\"12345\"* ]]\n}\n\n@test \"normalize_pattern: removes 6 digit PIDs\" {\n    local result\n    result=$(normalize_pattern \"process 123456 running\")\n    \n    [[ \"$result\" != *\"123456\"* ]]\n}\n\n@test \"normalize_pattern: keeps 4 digit numbers\" {\n    # 4-digit numbers might be ports, keep them (handled separately)\n    local result\n    result=$(normalize_pattern \"server on port 3000\")\n    \n    # Port normalization handles this, but raw 4-digit stays\n    [[ \"$result\" == *\"3000\"* ]] || [[ \"$result\" == *\"PORT\"* ]]\n}\n\n#------------------------------------------------------------------------------\n# Port normalization tests\n#------------------------------------------------------------------------------\n\n@test \"normalize_pattern: --port=3000 becomes --port=PORT\" {\n    local result\n    result=$(normalize_pattern \"next dev --port=3000\")\n    \n    [[ \"$result\" == *\"--port=PORT\"* ]]\n}\n\n@test \"normalize_pattern: --port 8080 becomes --port PORT\" {\n    local result\n    result=$(normalize_pattern \"server --port 8080\")\n    \n    [[ \"$result\" == *\"--port\"* ]] \u0026\u0026 [[ \"$result\" == *\"PORT\"* ]]\n}\n\n@test \"normalize_pattern: :8080 in URL becomes :PORT\" {\n    local result\n    result=$(normalize_pattern \"http://localhost:8080/api\")\n    \n    [[ \"$result\" == *\":PORT\"* ]]\n}\n\n@test \"normalize_pattern: :3000 becomes :PORT\" {\n    local result\n    result=$(normalize_pattern \"listening on :3000\")\n    \n    [[ \"$result\" == *\":PORT\"* ]]\n}\n\n#------------------------------------------------------------------------------\n# UUID normalization tests\n#------------------------------------------------------------------------------\n\n@test \"normalize_pattern: standard UUID becomes UUID\" {\n    local result\n    result=$(normalize_pattern \"process-550e8400-e29b-41d4-a716-446655440000-worker\")\n    \n    [[ \"$result\" == *\"UUID\"* ]]\n    [[ \"$result\" != *\"550e8400\"* ]]\n}\n\n@test \"normalize_pattern: multiple UUIDs normalized\" {\n    local result\n    result=$(normalize_pattern \"a1b2c3d4-e5f6-7890-abcd-ef1234567890 to 11111111-2222-3333-4444-555555555555\")\n    \n    # Should have UUID placeholder(s)\n    [[ \"$result\" == *\"UUID\"* ]]\n    [[ \"$result\" != *\"a1b2c3d4\"* ]]\n}\n\n#------------------------------------------------------------------------------\n# Temp path normalization tests\n#------------------------------------------------------------------------------\n\n@test \"normalize_pattern: /tmp/abc123 becomes /tmp/TMP\" {\n    local result\n    result=$(normalize_pattern \"node /tmp/abc123xyz/server.js\")\n    \n    [[ \"$result\" == *\"/tmp/TMP\"* ]]\n}\n\n@test \"normalize_pattern: complex temp paths normalized\" {\n    local result\n    result=$(normalize_pattern \"/tmp/pytest-of-user/pytest-123/test0\")\n    \n    [[ \"$result\" == *\"/tmp/TMP\"* ]]\n}\n\n#------------------------------------------------------------------------------\n# Whitespace normalization tests\n#------------------------------------------------------------------------------\n\n@test \"normalize_pattern: collapses multiple spaces\" {\n    local result\n    result=$(normalize_pattern \"command    with   many    spaces\")\n    \n    # Should not have multiple consecutive spaces\n    [[ \"$result\" != *\"  \"* ]]\n}\n\n@test \"normalize_pattern: trims leading/trailing whitespace\" {\n    local result\n    result=$(normalize_pattern \"  padded command  \")\n    \n    # Should not start or end with space\n    [[ \"$result\" != \" \"* ]]\n    [[ \"$result\" != *\" \" ]]\n}\n\n#------------------------------------------------------------------------------\n# Truncation tests\n#------------------------------------------------------------------------------\n\n@test \"normalize_pattern: long commands truncated to 150 chars\" {\n    local long_cmd=\"$(printf 'a%.0s' {1..200})\"\n    local result\n    result=$(normalize_pattern \"$long_cmd\")\n    \n    (( ${#result} \u003c= 150 ))\n}\n\n#------------------------------------------------------------------------------\n# Combined normalization tests\n#------------------------------------------------------------------------------\n\n@test \"normalize_pattern: complex command fully normalized\" {\n    local cmd=\"bun test --port=3000 /tmp/test123/spec 12345678 550e8400-e29b-41d4-a716-446655440000\"\n    local result\n    result=$(normalize_pattern \"$cmd\")\n    \n    # Port normalized\n    [[ \"$result\" == *\"--port=PORT\"* ]] || [[ \"$result\" == *\"--port PORT\"* ]]\n    # Temp path normalized\n    [[ \"$result\" == *\"/tmp/TMP\"* ]]\n    # PID removed\n    [[ \"$result\" != *\"12345678\"* ]]\n    # UUID normalized\n    [[ \"$result\" == *\"UUID\"* ]]\n}\n\n@test \"normalize_pattern: identical processes with different PIDs match\" {\n    local pattern1 pattern2\n    pattern1=$(normalize_pattern \"bun test --watch pid:12345\")\n    pattern2=$(normalize_pattern \"bun test --watch pid:67890\")\n    \n    [[ \"$pattern1\" == \"$pattern2\" ]]\n}\n\n@test \"normalize_pattern: identical processes with different ports match\" {\n    local pattern1 pattern2\n    pattern1=$(normalize_pattern \"next dev --port=3000\")\n    pattern2=$(normalize_pattern \"next dev --port=8080\")\n    \n    [[ \"$pattern1\" == \"$pattern2\" ]]\n}\n```\n\n## Success Criteria\n- [ ] PID removal tested\n- [ ] Port normalization tested (both formats)\n- [ ] UUID normalization tested\n- [ ] Temp path normalization tested\n- [ ] Whitespace handling tested\n- [ ] Truncation tested\n- [ ] Combined normalizations tested\n- [ ] Equivalence of similar processes verified","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:39:24.017811611-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:39:24.017811611-05:00","dependencies":[{"issue_id":"process_triage-45o","depends_on_id":"process_triage-h2y","type":"blocks","created_at":"2026-01-14T22:40:49.269246813-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-4l7","title":"Add E2E tests for self-update mechanism","description":"## Purpose\nCreate comprehensive end-to-end tests for the self-update mechanism to verify version checking, downloading, verification, and installation work correctly.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## Depends On\n- Test helper with mock injection (process_triage-h2y)\n- Add 'pt update' command to CLI (process_triage-a50) - tests should be ready when feature lands\n\n## Why This Is Critical\nThe self-update mechanism:\n- Modifies the running script\n- Downloads from the internet\n- Executes checksums\n- Has security implications\n\nIf it fails, users could be left with a broken tool. Comprehensive testing prevents this.\n\n## Test Scenarios\n\n### test/test_e2e_update.bats\n\n```bash\n#!/usr/bin/env bats\n\nload 'test_helper/common'\n\nsetup() {\n    setup_test_env\n    test_start \"$BATS_TEST_NAME\" \"Self-update E2E test\"\n    \n    # Create a copy of pt for testing (don't modify real script)\n    export PT_TEST_SCRIPT=\"${TEST_DIR}/pt_test_copy\"\n    cp \"${BATS_TEST_DIRNAME}/../pt\" \"$PT_TEST_SCRIPT\"\n    chmod +x \"$PT_TEST_SCRIPT\"\n}\n\nteardown() {\n    test_end \"$BATS_TEST_NAME\" \"${BATS_TEST_COMPLETED:-fail}\"\n    restore_path\n    teardown_test_env\n}\n\n#==============================================================================\n# VERSION CHECKING TESTS\n#==============================================================================\n\n@test \"E2E Update: --check detects newer version available\" {\n    test_info \"Setting up: mock curl to return newer version URL\"\n    \n    # Current version in script (extract it)\n    local current_version\n    current_version=$(grep '^VERSION=' \"$PT_TEST_SCRIPT\" | cut -d'\"' -f2)\n    test_info \"Current version: $current_version\"\n    \n    # Mock curl to simulate redirect to newer version\n    create_mock_curl_redirect \"https://github.com/user/repo/releases/tag/v99.0.0\"\n    use_mock_bin\n    \n    test_info \"Running: pt update --check\"\n    run \"$PT_TEST_SCRIPT\" update --check\n    \n    test_info \"Exit code: $status, Output: $output\"\n    \n    # Should indicate update available\n    assert_contains \"$output\" \"available\\|99.0.0\" \"Should show newer version\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E Update: --check shows already up to date\" {\n    test_info \"Setting up: mock curl to return current version URL\"\n    \n    local current_version\n    current_version=$(grep '^VERSION=' \"$PT_TEST_SCRIPT\" | cut -d'\"' -f2)\n    test_info \"Current version: $current_version\"\n    \n    # Mock curl to return current version\n    create_mock_curl_redirect \"https://github.com/user/repo/releases/tag/v${current_version}\"\n    use_mock_bin\n    \n    test_info \"Running: pt update --check\"\n    run \"$PT_TEST_SCRIPT\" update --check\n    \n    test_info \"Exit code: $status, Output: $output\"\n    \n    # Should indicate up to date\n    assert_contains \"$output\" \"latest\\|up to date\\|$current_version\" \"Should show current\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E Update: handles network failure gracefully\" {\n    test_info \"Setting up: mock curl to fail\"\n    \n    create_mock_command \"curl\" \"\" 1  # Exit with error\n    use_mock_bin\n    \n    test_info \"Running: pt update --check\"\n    run \"$PT_TEST_SCRIPT\" update --check\n    \n    test_info \"Exit code: $status, Output: $output\"\n    \n    # Should fail gracefully with helpful message\n    # Don't crash, show network error\n    assert_contains \"$output\" \"error\\|failed\\|network\\|connection\" \"Should indicate network issue\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# CHECKSUM VERIFICATION TESTS\n#==============================================================================\n\n@test \"E2E Update: verifies checksum before installation\" {\n    test_info \"Setting up: mock download with correct checksum\"\n    \n    # Create a mock new version script\n    local mock_new_script=\"${TEST_DIR}/mock_new_pt\"\n    cat \u003e \"$mock_new_script\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"99.0.0\"\necho \"Mock new version\"\nEOF\n    \n    # Calculate its checksum\n    local checksum\n    if command -v sha256sum \u0026\u003e/dev/null; then\n        checksum=$(sha256sum \"$mock_new_script\" | cut -d' ' -f1)\n    else\n        checksum=$(shasum -a 256 \"$mock_new_script\" | cut -d' ' -f1)\n    fi\n    test_info \"Mock script checksum: $checksum\"\n    \n    # Mock curl to return appropriate responses\n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\nif [[ \"\\$*\" == *\"url_effective\"* ]]; then\n    echo \"https://github.com/user/repo/releases/tag/v99.0.0\"\nelif [[ \"\\$*\" == *\".sha256\"* ]]; then\n    echo \"$checksum  pt\"\nelif [[ \"\\$*\" == *\"/pt\"* ]]; then\n    cat \"$mock_new_script\"\nfi\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Checksum verification test setup complete\"\n    \n    # The actual update would need more mocking...\n    # This tests the infrastructure is in place\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E Update: rejects mismatched checksum\" {\n    test_info \"Setting up: mock download with WRONG checksum\"\n    \n    # Create a mock script\n    local mock_new_script=\"${TEST_DIR}/mock_bad_pt\"\n    echo '#!/bin/bash' \u003e \"$mock_new_script\"\n    echo 'VERSION=\"99.0.0\"' \u003e\u003e \"$mock_new_script\"\n    \n    # Provide WRONG checksum\n    local wrong_checksum=\"0000000000000000000000000000000000000000000000000000000000000000\"\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\nif [[ \"\\$*\" == *\"url_effective\"* ]]; then\n    echo \"https://github.com/user/repo/releases/tag/v99.0.0\"\nelif [[ \"\\$*\" == *\".sha256\"* ]]; then\n    echo \"$wrong_checksum  pt\"\nelif [[ \"\\$*\" == *\"/pt\"* ]]; then\n    cat \"$mock_new_script\"\nfi\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running update with wrong checksum (should fail)\"\n    \n    # This should be rejected\n    # Actual test depends on implementation\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# SYNTAX VALIDATION TESTS\n#==============================================================================\n\n@test \"E2E Update: rejects invalid bash syntax\" {\n    test_info \"Setting up: mock download with syntax error\"\n    \n    # Create a script with syntax error\n    local bad_script=\"${TEST_DIR}/bad_syntax.sh\"\n    cat \u003e \"$bad_script\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"99.0.0\"\nif [[ true ]]; then\n    echo \"missing fi\"\n# Note: missing 'fi' - syntax error\nEOF\n    \n    test_info \"Verifying bash -n detects syntax error\"\n    run bash -n \"$bad_script\"\n    [[ $status -ne 0 ]]\n    test_info \"bash -n correctly rejected bad syntax\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E Update: accepts valid bash syntax\" {\n    test_info \"Setting up: mock download with valid syntax\"\n    \n    local good_script=\"${TEST_DIR}/good_syntax.sh\"\n    cat \u003e \"$good_script\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"99.0.0\"\nif [[ true ]]; then\n    echo \"valid syntax\"\nfi\nEOF\n    \n    test_info \"Verifying bash -n accepts good syntax\"\n    run bash -n \"$good_script\"\n    assert_equals \"0\" \"$status\" \"Should accept valid syntax\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# ATOMIC REPLACEMENT TESTS\n#==============================================================================\n\n@test \"E2E Update: atomic replacement preserves original on failure\" {\n    test_info \"This test verifies atomic replacement behavior\"\n    \n    # Create original script\n    local original=\"${TEST_DIR}/original_script\"\n    echo '#!/bin/bash' \u003e \"$original\"\n    echo 'VERSION=\"1.0.0\"' \u003e\u003e \"$original\"\n    chmod +x \"$original\"\n    \n    # Store original content hash\n    local original_hash\n    original_hash=$(sha256sum \"$original\" 2\u003e/dev/null | cut -d' ' -f1 || shasum -a 256 \"$original\" | cut -d' ' -f1)\n    test_info \"Original hash: $original_hash\"\n    \n    # If replacement fails, original should be unchanged\n    # This is more of an integration test with the atomic_replace function\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E Update: atomic replacement sets correct permissions\" {\n    test_info \"Verifying permissions preservation\"\n    \n    local test_script=\"${TEST_DIR}/perm_test\"\n    echo '#!/bin/bash' \u003e \"$test_script\"\n    chmod 755 \"$test_script\"\n    \n    local original_perms\n    original_perms=$(stat -c '%a' \"$test_script\" 2\u003e/dev/null || stat -f '%Lp' \"$test_script\")\n    test_info \"Original permissions: $original_perms\"\n    \n    assert_equals \"755\" \"$original_perms\" \"Permissions should be 755\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# PERMISSION HANDLING TESTS\n#==============================================================================\n\n@test \"E2E Update: detects unwritable installation directory\" {\n    skip_if_root  # Root can write anywhere\n    \n    test_info \"Setting up: read-only directory\"\n    \n    local readonly_dir=\"${TEST_DIR}/readonly\"\n    mkdir -p \"$readonly_dir\"\n    \n    local test_script=\"${readonly_dir}/pt\"\n    echo '#!/bin/bash' \u003e \"$test_script\"\n    chmod +x \"$test_script\"\n    \n    # Make directory read-only\n    chmod 555 \"$readonly_dir\"\n    \n    test_info \"Verifying directory is not writable\"\n    [[ ! -w \"$readonly_dir\" ]]\n    \n    # Restore permissions for cleanup\n    chmod 755 \"$readonly_dir\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# INTEGRATION TESTS\n#==============================================================================\n\n@test \"E2E Update: full update flow with mocks\" {\n    test_info \"Full update flow integration test\"\n    \n    # This is the big integration test that simulates the entire flow:\n    # 1. Check for updates\n    # 2. Download new version\n    # 3. Verify checksum\n    # 4. Validate syntax\n    # 5. Atomic replacement\n    \n    # For safety, we don't actually replace anything\n    # Instead we verify each step would work\n    \n    test_info \"Step 1: Version check\"\n    # ... mock version check ...\n    \n    test_info \"Step 2: Download simulation\"\n    # ... verify download would succeed ...\n    \n    test_info \"Step 3: Checksum verification\"\n    # ... verify checksum logic ...\n    \n    test_info \"Step 4: Syntax validation\"\n    # ... verify syntax check ...\n    \n    test_info \"Step 5: Atomic replacement preparation\"\n    # ... verify replacement would be atomic ...\n    \n    BATS_TEST_COMPLETED=pass\n}\n```\n\n## Success Criteria\n- [ ] Version checking tested (newer, current, failure)\n- [ ] Checksum verification tested (match, mismatch, missing)\n- [ ] Syntax validation tested (valid, invalid)\n- [ ] Atomic replacement tested (success, failure preservation)\n- [ ] Permission handling tested\n- [ ] Network failure handling tested\n- [ ] All tests have detailed logging\n- [ ] No actual script replacement in tests (safety)","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:47:26.873195395-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:47:26.873195395-05:00","dependencies":[{"issue_id":"process_triage-4l7","depends_on_id":"process_triage-h2y","type":"blocks","created_at":"2026-01-14T22:50:29.765439879-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-4l7","depends_on_id":"process_triage-a50","type":"blocks","created_at":"2026-01-14T22:50:29.810950859-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-4ps","title":"Add checksum verification for updates","description":"## Purpose\nVerify downloaded updates using SHA256 checksums before installation, ensuring security and integrity.\n\n## Parent Epic\nSelf-Update Mechanism (process_triage-097)\n\n## Depends On\n- Implement HTTP redirect-based version checking\n- Release automation must generate checksums (process_triage-aip)\n\n## Security Model\n1. Checksums are generated in CI (trusted environment)\n2. Published as release artifacts on GitHub\n3. Downloaded and verified locally before installation\n4. Mismatch = abort update (potential tampering)\n\n## Implementation\n\n### Checksum Download and Verification\n```bash\n#------------------------------------------------------------------------------\n# Checksum verification\n#------------------------------------------------------------------------------\n\nverify_checksum() {\n    local file=\"$1\"\n    local version=\"$2\"\n    local expected actual\n    \n    # Download expected checksum from release\n    local checksum_url=\"${RELEASES_URL}/download/v${version}/pt.sha256\"\n    \n    expected=$(curl -fsSL --connect-timeout 5 --max-time 10 \"$checksum_url\" 2\u003e/dev/null)\n    \n    if [[ -z \"$expected\" ]]; then\n        log_warn \"Could not download checksum file\"\n        log_warn \"Update will proceed WITHOUT verification\"\n        \n        # In non-interactive mode, refuse to continue\n        if [[ \"$IS_TTY\" \\!= \"true\" ]]; then\n            log_error \"Checksum verification required in non-interactive mode\"\n            return 1\n        fi\n        \n        # Ask user to confirm\n        if \\! gum_confirm \"Continue without checksum verification?\"; then\n            return 1\n        fi\n        return 0\n    fi\n    \n    # Extract just the hash (file format: \"hash  filename\")\n    expected=\"${expected%% *}\"\n    \n    # Compute actual checksum (cross-platform)\n    if command -v sha256sum \u0026\u003e/dev/null; then\n        actual=$(sha256sum \"$file\" | cut -d' ' -f1)\n    elif command -v shasum \u0026\u003e/dev/null; then\n        actual=$(shasum -a 256 \"$file\" | cut -d' ' -f1)\n    else\n        log_warn \"No SHA256 tool available, skipping verification\"\n        return 0\n    fi\n    \n    # Compare\n    if [[ \"$expected\" == \"$actual\" ]]; then\n        log_success \"Checksum verified: ${actual:0:16}...\"\n        return 0\n    else\n        log_error \"Checksum mismatch\\!\"\n        log_error \"  Expected: $expected\"\n        log_error \"  Actual:   $actual\"\n        log_error \"The downloaded file may be corrupted or tampered with.\"\n        return 1\n    fi\n}\n```\n\n### Integration with Update Flow\n```bash\ndo_update() {\n    local version=\"$1\"\n    local download_url=\"${RELEASES_URL}/download/v${version}/pt\"\n    local temp_file\n    \n    # Create temp file in same directory (for atomic move later)\n    temp_file=\"$(mktemp \"${SCRIPT_PATH}.XXXXXX\")\"\n    trap \"rm -f '$temp_file'\" EXIT\n    \n    # Download\n    log_step \"Downloading pt v${version}...\"\n    if \\! curl -fsSL --connect-timeout 10 --max-time 60 \"$download_url\" -o \"$temp_file\"; then\n        log_error \"Download failed\"\n        return 1\n    fi\n    \n    # Verify checksum\n    if \\! verify_checksum \"$temp_file\" \"$version\"; then\n        log_error \"Checksum verification failed, aborting update\"\n        return 1\n    fi\n    \n    # Continue with syntax validation and installation...\n}\n```\n\n## Cross-Platform SHA256 Tools\n| Platform | Tool |\n|----------|------|\n| Linux (most) | sha256sum |\n| macOS | shasum -a 256 |\n| BSD | sha256 |\n\nThe implementation tries sha256sum first (most common), then shasum (macOS).\n\n## Checksum File Format\nThe release will include:\n```\n# checksums.sha256 (combined)\nabc123...  pt\ndef456...  install.sh\n\n# pt.sha256 (individual - used by installer)\nabc123...  pt\n```\n\n## Success Criteria\n- [ ] Checksums downloaded from release artifacts\n- [ ] SHA256 verification works on Linux and macOS\n- [ ] Mismatch aborts update with clear message\n- [ ] Missing checksum prompts user (or fails in non-interactive)\n- [ ] Partial checksum displayed on success","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:35:02.949837945-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:35:02.949837945-05:00","dependencies":[{"issue_id":"process_triage-4ps","depends_on_id":"process_triage-nk1","type":"blocks","created_at":"2026-01-14T22:52:20.652411692-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-5aw","title":"Add installation test job to CI","description":"## Purpose\nAdd a CI job that tests the installer end-to-end on both Linux and macOS.\n\n## Parent Epic\nGitHub Actions CI/CD Pipeline (process_triage-68c)\n\n## Depends On\n- Create install.sh with self-refresh mechanism\n- Add BATS test job with matrix build\n\n## Why Installation Testing?\n- Verifies installer works on clean systems\n- Catches PATH issues, permission problems\n- Tests the actual user experience\n- Ensures --version and --help work post-install\n\n## Implementation\n\n### Add to ci.yml\n```yaml\n  install-test:\n    name: Installation Test (${{ matrix.os }})\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-latest, macos-latest]\n    \n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Install Bash 5 (macOS)\n        if: runner.os == 'macOS'\n        run: |\n          brew install bash\n          echo \"/opt/homebrew/bin\" \u003e\u003e $GITHUB_PATH\n      \n      - name: Run installer\n        run: |\n          # Run installer from local file (not curl, since we're testing the branch)\n          bash install.sh\n        env:\n          PT_NO_PATH: '1'  # Don't modify shell config in CI\n      \n      - name: Verify installation\n        run: |\n          # Check executable exists\n          if [[ \\! -x \"$HOME/.local/bin/pt\" ]]; then\n            echo \"::error::pt not installed to expected location\"\n            ls -la \"$HOME/.local/bin/\" || true\n            exit 1\n          fi\n          \n          echo \"✓ pt installed successfully\"\n      \n      - name: Test --version\n        run: |\n          version=$(\"$HOME/.local/bin/pt\" --version)\n          echo \"Version output: $version\"\n          \n          if [[ \\! \"$version\" =~ ^pt\\ version\\ [0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n            echo \"::error::Unexpected version output format\"\n            exit 1\n          fi\n          \n          echo \"✓ --version works correctly\"\n      \n      - name: Test --help\n        run: |\n          help_output=$(\"$HOME/.local/bin/pt\" --help)\n          \n          # Check for expected content\n          if [[ \"$help_output\" \\!= *\"Process Triage\"* ]]; then\n            echo \"::error::Help output missing expected content\"\n            exit 1\n          fi\n          \n          if [[ \"$help_output\" \\!= *\"scan\"* ]]; then\n            echo \"::error::Help output missing 'scan' command\"\n            exit 1\n          fi\n          \n          echo \"✓ --help works correctly\"\n      \n      - name: Test scan command\n        run: |\n          # scan should work (may find 0 candidates, that's OK)\n          \"$HOME/.local/bin/pt\" scan || {\n            echo \"::error::pt scan failed\"\n            exit 1\n          }\n          echo \"✓ scan command works\"\n        env:\n          CI: 'true'\n          NO_COLOR: '1'\n```\n\n## Environment Variables for CI\n- `PT_NO_PATH='1'`: Don't modify .bashrc/.zshrc in CI\n- `CI='true'`: pt should detect CI environment\n- `NO_COLOR='1'`: Disable colors for clean output\n\n## Success Criteria\n- [ ] Installer runs without error\n- [ ] pt installed to ~/.local/bin/\n- [ ] --version returns correct format\n- [ ] --help shows expected content\n- [ ] scan command executes without error\n- [ ] Works on both Linux and macOS","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:37:33.12590461-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:37:33.12590461-05:00","dependencies":[{"issue_id":"process_triage-5aw","depends_on_id":"process_triage-ume","type":"blocks","created_at":"2026-01-14T22:40:46.394310829-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-5aw","depends_on_id":"process_triage-9ch","type":"blocks","created_at":"2026-01-14T22:40:46.441625327-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-68c","title":"GitHub Actions CI/CD Pipeline","description":"## Overview\nImplement a comprehensive CI/CD pipeline matching the quality standards of repo_updater and giil.\n\n## Current State\n- NO GitHub Actions workflows exist\n- No automated testing on push/PR\n- No ShellCheck linting\n- No cross-platform testing\n- No version consistency checks\n\n## Target State\nTwo workflow files:\n1. **ci.yml** - Runs on every push/PR\n2. **release.yml** - Runs on version tags\n\n## ci.yml Structure (from repo_updater pattern)\n\n### Job 1: ShellCheck (Static Analysis)\n```yaml\nshellcheck:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: ludeeus/action-shellcheck@master\n      with:\n        severity: warning\n        scandir: '.'\n```\n\n### Job 2: Syntax Validation\n```yaml\nsyntax:\n  runs-on: ubuntu-latest\n  steps:\n    - run: bash -n pt\n    - run: bash -n install.sh\n```\n\n### Job 3: BATS Tests (Matrix Build)\n```yaml\ntests:\n  strategy:\n    matrix:\n      os: [ubuntu-latest, macos-latest]\n  steps:\n    - name: Install BATS\n      run: |\n        git clone https://github.com/bats-core/bats-core.git\n        cd bats-core \u0026\u0026 sudo ./install.sh /usr/local\n    - name: Run tests\n      run: bats test/\n```\n\n### Job 4: Installation Test\n```yaml\ninstall-test:\n  strategy:\n    matrix:\n      os: [ubuntu-latest, macos-latest]\n  steps:\n    - run: bash install.sh\n    - run: pt --version\n    - run: pt --help\n```\n\n### Job 5: Version Consistency\n```yaml\nversion-check:\n  steps:\n    - name: Verify VERSION matches script\n      run: |\n        file_version=$(cat VERSION)\n        script_version=$(grep '^VERSION=' pt | cut -d= -f2 | tr -d '\"')\n        [[ \"$file_version\" == \"$script_version\" ]] || exit 1\n```\n\n## Trigger Configuration\n```yaml\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n  workflow_dispatch:  # Manual trigger\n```\n\n## Why This Structure?\n- **ShellCheck**: Catches common bash pitfalls before they reach users\n- **Syntax validation**: Ensures script is parseable (catches heredoc issues)\n- **Matrix testing**: Ensures cross-platform compatibility\n- **Version check**: Prevents release version mismatches (common source of bugs)\n- **Install test**: Validates the user experience works end-to-end\n\n## Success Criteria\n- [ ] All jobs pass on clean codebase\n- [ ] PRs are blocked if any job fails\n- [ ] Tests run on both Linux and macOS\n- [ ] Version mismatches are caught before release\n- [ ] ShellCheck warnings are addressed","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:32:43.023581917-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:32:43.023581917-05:00"}
{"id":"process_triage-6jg","title":"Add decision memory tests","description":"## Purpose\nAdd tests for the decision memory system that learns from user choices.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## Key Functions to Test\n- `save_decision()`: Persist kill/spare decisions\n- `get_past_decision()`: Retrieve previous decision\n- `load_decisions_cache()`: Batch load for performance\n- `get_cached_decision()`: Fast lookup from cache\n\n## Implementation\n\n### test/test_memory.bats\n```bash\n#\\!/usr/bin/env bats\n\nsetup() {\n    # Create isolated config directory for each test\n    export CONFIG_DIR=\"${BATS_TEST_TMPDIR}/config\"\n    export DECISIONS_FILE=\"${CONFIG_DIR}/decisions.json\"\n    mkdir -p \"$CONFIG_DIR\"\n    echo '{}' \u003e \"$DECISIONS_FILE\"\n    \n    export TEST_MODE=1\n    source \"${BATS_TEST_DIRNAME}/../pt\" 2\u003e/dev/null || true\n}\n\nteardown() {\n    rm -rf \"${BATS_TEST_TMPDIR}/config\"\n}\n\n#------------------------------------------------------------------------------\n# save_decision tests\n#------------------------------------------------------------------------------\n\n@test \"save_decision: creates valid JSON\" {\n    skip_if_no_jq\n    \n    save_decision \"kill\" \"test pattern\"\n    \n    # Should be valid JSON\n    jq -e '.' \"$DECISIONS_FILE\" \u003e/dev/null\n}\n\n@test \"save_decision: stores kill decision\" {\n    skip_if_no_jq\n    \n    save_decision \"kill\" \"bun test\"\n    \n    local stored\n    stored=$(jq -r '.\"bun test\"' \"$DECISIONS_FILE\")\n    [[ \"$stored\" == \"kill\" ]]\n}\n\n@test \"save_decision: stores spare decision\" {\n    skip_if_no_jq\n    \n    save_decision \"spare\" \"gunicorn\"\n    \n    local stored\n    stored=$(jq -r '.gunicorn' \"$DECISIONS_FILE\")\n    [[ \"$stored\" == \"spare\" ]]\n}\n\n@test \"save_decision: overwrites previous decision\" {\n    skip_if_no_jq\n    \n    save_decision \"kill\" \"pattern1\"\n    save_decision \"spare\" \"pattern1\"\n    \n    local stored\n    stored=$(jq -r '.pattern1' \"$DECISIONS_FILE\")\n    [[ \"$stored\" == \"spare\" ]]\n}\n\n@test \"save_decision: handles patterns with special characters\" {\n    skip_if_no_jq\n    \n    save_decision \"kill\" \"path/to/file --flag=\\\"value\\\"\"\n    \n    # Should not corrupt JSON\n    jq -e '.' \"$DECISIONS_FILE\" \u003e/dev/null\n}\n\n@test \"save_decision: handles multiple patterns\" {\n    skip_if_no_jq\n    \n    save_decision \"kill\" \"pattern1\"\n    save_decision \"spare\" \"pattern2\"\n    save_decision \"kill\" \"pattern3\"\n    \n    local count\n    count=$(jq 'length' \"$DECISIONS_FILE\")\n    (( count == 3 ))\n}\n\n#------------------------------------------------------------------------------\n# get_past_decision tests\n#------------------------------------------------------------------------------\n\n@test \"get_past_decision: returns stored decision\" {\n    skip_if_no_jq\n    \n    echo '{\"bun test\": \"kill\"}' \u003e \"$DECISIONS_FILE\"\n    \n    local result\n    result=$(get_past_decision \"bun test\")\n    [[ \"$result\" == \"kill\" ]]\n}\n\n@test \"get_past_decision: returns unknown for missing pattern\" {\n    skip_if_no_jq\n    \n    echo '{}' \u003e \"$DECISIONS_FILE\"\n    \n    local result\n    result=$(get_past_decision \"nonexistent\")\n    [[ \"$result\" == \"unknown\" ]]\n}\n\n#------------------------------------------------------------------------------\n# Cache tests\n#------------------------------------------------------------------------------\n\n@test \"load_decisions_cache: loads all decisions\" {\n    skip_if_no_jq\n    \n    echo '{\"p1\": \"kill\", \"p2\": \"spare\", \"p3\": \"kill\"}' \u003e \"$DECISIONS_FILE\"\n    \n    load_decisions_cache\n    \n    [[ \"${DECISION_CACHE[p1]}\" == \"kill\" ]]\n    [[ \"${DECISION_CACHE[p2]}\" == \"spare\" ]]\n    [[ \"${DECISION_CACHE[p3]}\" == \"kill\" ]]\n}\n\n@test \"get_cached_decision: fast lookup\" {\n    skip_if_no_jq\n    \n    echo '{\"cached_pattern\": \"spare\"}' \u003e \"$DECISIONS_FILE\"\n    load_decisions_cache\n    \n    local result\n    result=$(get_cached_decision \"cached_pattern\")\n    [[ \"$result\" == \"spare\" ]]\n}\n\n@test \"get_cached_decision: returns unknown for missing\" {\n    skip_if_no_jq\n    \n    echo '{}' \u003e \"$DECISIONS_FILE\"\n    load_decisions_cache\n    \n    local result\n    result=$(get_cached_decision \"missing\")\n    [[ \"$result\" == \"unknown\" ]]\n}\n\n#------------------------------------------------------------------------------\n# Integration tests\n#------------------------------------------------------------------------------\n\n@test \"decision memory: affects scoring\" {\n    skip_if_no_jq\n    \n    # Save a kill decision\n    save_decision \"kill\" \"previous pattern\"\n    \n    # Score should be boosted for similar pattern\n    # This tests the integration with score_process\n}\n\n@test \"decision memory: survives script restart\" {\n    skip_if_no_jq\n    \n    save_decision \"kill\" \"persistent pattern\"\n    \n    # Clear cache (simulating restart)\n    unset DECISION_CACHE\n    declare -gA DECISION_CACHE\n    DECISION_CACHE_LOADED=false\n    \n    # Reload and verify\n    load_decisions_cache\n    [[ \"${DECISION_CACHE[persistent pattern]}\" == \"kill\" ]]\n}\n\n#------------------------------------------------------------------------------\n# Helper\n#------------------------------------------------------------------------------\n\nskip_if_no_jq() {\n    if \\! command -v jq \u0026\u003e/dev/null; then\n        skip \"jq not installed\"\n    fi\n}\n```\n\n## Success Criteria\n- [ ] save_decision creates valid JSON\n- [ ] Both kill and spare decisions stored\n- [ ] Decisions can be retrieved\n- [ ] Cache loading works\n- [ ] Fast lookup from cache works\n- [ ] Special characters handled safely\n- [ ] Unknown patterns return \"unknown\"","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:39:24.279254142-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:39:24.279254142-05:00","dependencies":[{"issue_id":"process_triage-6jg","depends_on_id":"process_triage-h2y","type":"blocks","created_at":"2026-01-14T22:40:49.312857184-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-6xm","title":"Add E2E tests for installer (install.sh)","description":"## Purpose\nCreate comprehensive end-to-end tests for install.sh to verify the installation process works correctly across different scenarios.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## Depends On\n- Test helper with mock injection (process_triage-h2y)\n- Create install.sh with self-refresh mechanism (process_triage-ume) - tests ready when feature lands\n\n## Test Scenarios\n\n### test/test_e2e_installer.bats\n\n```bash\n#!/usr/bin/env bats\n\nload 'test_helper/common'\n\nsetup() {\n    setup_test_env\n    test_start \"$BATS_TEST_NAME\" \"Installer E2E test\"\n    \n    export INSTALL_SCRIPT=\"${BATS_TEST_DIRNAME}/../install.sh\"\n    export INSTALL_DIR=\"${TEST_DIR}/install_target\"\n    mkdir -p \"$INSTALL_DIR\"\n}\n\nteardown() {\n    test_end \"$BATS_TEST_NAME\" \"${BATS_TEST_COMPLETED:-fail}\"\n    restore_path\n    teardown_test_env\n}\n\n#==============================================================================\n# BASIC INSTALLATION TESTS\n#==============================================================================\n\n@test \"Installer: script exists and is executable\" {\n    test_info \"Checking install.sh exists\"\n    \n    [[ -f \"$INSTALL_SCRIPT\" ]]\n    [[ -r \"$INSTALL_SCRIPT\" ]]\n    \n    test_info \"Verifying bash syntax\"\n    run bash -n \"$INSTALL_SCRIPT\"\n    assert_equals \"0\" \"$status\" \"install.sh should have valid syntax\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Installer: fresh install to custom directory\" {\n    test_info \"Setting up: custom DEST directory\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export PT_NO_PATH=1  # Don't modify shell config\n    \n    # Mock curl to return a valid pt script\n    local mock_pt=\"${TEST_DIR}/mock_pt\"\n    cat \u003e \"$mock_pt\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"1.0.0\"\necho \"pt - Process Triage\"\nEOF\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\nif [[ \"\\$*\" == *\"url_effective\"* ]]; then\n    echo \"https://github.com/user/repo/releases/tag/v1.0.0\"\nelif [[ \"\\$*\" == *\"VERSION\"* ]]; then\n    echo \"1.0.0\"\nelif [[ \"\\$*\" == *\"/pt\"* ]] || [[ \"\\$*\" == *\"pt\\$\"* ]]; then\n    cat \"$mock_pt\"\nfi\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running installer with DEST=$DEST\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    test_info \"Exit code: $status\"\n    test_info \"Output: $output\"\n    \n    # Should succeed\n    assert_equals \"0\" \"$status\" \"Installer should succeed\"\n    \n    # Should create pt in target directory\n    [[ -f \"${INSTALL_DIR}/pt\" ]]\n    [[ -x \"${INSTALL_DIR}/pt\" ]]\n    \n    test_info \"Verified: pt installed to $INSTALL_DIR\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Installer: upgrade existing installation\" {\n    test_info \"Setting up: existing installation\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export PT_NO_PATH=1\n    \n    # Create \"old\" version\n    cat \u003e \"${INSTALL_DIR}/pt\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"0.9.0\"\necho \"Old version\"\nEOF\n    chmod +x \"${INSTALL_DIR}/pt\"\n    \n    test_info \"Old version installed: 0.9.0\"\n    \n    # Mock curl for \"new\" version\n    local mock_new_pt=\"${TEST_DIR}/mock_new_pt\"\n    cat \u003e \"$mock_new_pt\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"1.0.0\"\necho \"New version\"\nEOF\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\nif [[ \"\\$*\" == *\"url_effective\"* ]]; then\n    echo \"https://github.com/user/repo/releases/tag/v1.0.0\"\nelif [[ \"\\$*\" == *\"VERSION\"* ]]; then\n    echo \"1.0.0\"\nelse\n    cat \"$mock_new_pt\"\nfi\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running installer (upgrade scenario)\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    # Should show upgrade message\n    # Output should mention version change\n    \n    test_info \"Verifying version was upgraded\"\n    local installed_version\n    installed_version=$(grep 'VERSION=' \"${INSTALL_DIR}/pt\" | cut -d'\"' -f2)\n    assert_equals \"1.0.0\" \"$installed_version\" \"Should upgrade to new version\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# CHECKSUM VERIFICATION TESTS\n#==============================================================================\n\n@test \"Installer: VERIFY=1 checks checksum\" {\n    test_info \"Setting up: checksum verification enabled\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export PT_NO_PATH=1\n    export VERIFY=1\n    \n    # Create mock pt and calculate real checksum\n    local mock_pt=\"${TEST_DIR}/mock_pt\"\n    cat \u003e \"$mock_pt\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"1.0.0\"\nEOF\n    \n    local real_checksum\n    real_checksum=$(sha256sum \"$mock_pt\" 2\u003e/dev/null | cut -d' ' -f1 || shasum -a 256 \"$mock_pt\" | cut -d' ' -f1)\n    test_info \"Real checksum: $real_checksum\"\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\nif [[ \"\\$*\" == *\"url_effective\"* ]]; then\n    echo \"https://github.com/user/repo/releases/tag/v1.0.0\"\nelif [[ \"\\$*\" == *\".sha256\"* ]]; then\n    echo \"$real_checksum  pt\"\nelse\n    cat \"$mock_pt\"\nfi\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running installer with VERIFY=1\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    test_info \"Exit code: $status\"\n    assert_equals \"0\" \"$status\" \"Should succeed with valid checksum\"\n    \n    # Output should mention verification\n    assert_contains \"$output\" \"verify\\|checksum\\|Checksum\" \"Should mention verification\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Installer: VERIFY=1 fails on checksum mismatch\" {\n    test_info \"Setting up: checksum mismatch scenario\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export PT_NO_PATH=1\n    export VERIFY=1\n    \n    local mock_pt=\"${TEST_DIR}/mock_pt\"\n    echo '#!/bin/bash' \u003e \"$mock_pt\"\n    \n    # Provide WRONG checksum\n    local wrong_checksum=\"deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef\"\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\nif [[ \"\\$*\" == *\"url_effective\"* ]]; then\n    echo \"https://github.com/user/repo/releases/tag/v1.0.0\"\nelif [[ \"\\$*\" == *\".sha256\"* ]]; then\n    echo \"$wrong_checksum  pt\"\nelse\n    cat \"$mock_pt\"\nfi\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running installer with wrong checksum\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    test_info \"Exit code: $status\"\n    \n    # Should fail\n    [[ $status -ne 0 ]]\n    \n    # Should mention checksum failure\n    assert_contains \"$output\" \"mismatch\\|fail\\|error\" \"Should indicate checksum failure\"\n    \n    # Should NOT install\n    [[ ! -f \"${INSTALL_DIR}/pt\" ]]\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# PATH MANAGEMENT TESTS\n#==============================================================================\n\n@test \"Installer: adds to PATH in bashrc\" {\n    test_info \"Setting up: bash user\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export SHELL=\"/bin/bash\"\n    export HOME=\"$TEST_DIR\"\n    \n    # Create .bashrc\n    touch \"${HOME}/.bashrc\"\n    \n    # Mock curl\n    local mock_pt=\"${TEST_DIR}/mock_pt\"\n    echo '#!/bin/bash' \u003e \"$mock_pt\"\n    echo 'VERSION=\"1.0.0\"' \u003e\u003e \"$mock_pt\"\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\ncat \"$mock_pt\"\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running installer (should modify .bashrc)\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    # Check .bashrc was modified\n    if [[ -f \"${HOME}/.bashrc\" ]]; then\n        test_info \".bashrc contents:\"\n        cat \"${HOME}/.bashrc\"\n        \n        # Should contain PATH export\n        grep -q \"$INSTALL_DIR\" \"${HOME}/.bashrc\" || true\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Installer: PT_NO_PATH=1 skips PATH modification\" {\n    test_info \"Setting up: PT_NO_PATH=1\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export PT_NO_PATH=1\n    export HOME=\"$TEST_DIR\"\n    \n    touch \"${HOME}/.bashrc\"\n    local original_content=\"# Original bashrc\"\n    echo \"$original_content\" \u003e \"${HOME}/.bashrc\"\n    \n    # Mock curl\n    local mock_pt=\"${TEST_DIR}/mock_pt\"\n    echo '#!/bin/bash' \u003e \"$mock_pt\"\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\ncat \"$mock_pt\"\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running installer with PT_NO_PATH=1\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    test_info \"Verifying .bashrc unchanged\"\n    local final_content\n    final_content=$(cat \"${HOME}/.bashrc\")\n    assert_equals \"$original_content\" \"$final_content\" \".bashrc should be unchanged\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# ERROR HANDLING TESTS\n#==============================================================================\n\n@test \"Installer: handles network failure gracefully\" {\n    test_info \"Setting up: network failure simulation\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export PT_NO_PATH=1\n    \n    # Mock curl to fail\n    create_mock_command \"curl\" \"Connection refused\" 1\n    use_mock_bin\n    \n    test_info \"Running installer (should fail gracefully)\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    test_info \"Exit code: $status\"\n    \n    # Should fail\n    [[ $status -ne 0 ]]\n    \n    # Should show helpful error\n    assert_contains \"$output\" \"error\\|fail\\|download\" \"Should indicate download failure\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Installer: specific version via PT_VERSION\" {\n    test_info \"Setting up: specific version installation\"\n    \n    export DEST=\"$INSTALL_DIR\"\n    export PT_NO_PATH=1\n    export PT_VERSION=\"1.2.3\"\n    \n    local mock_pt=\"${TEST_DIR}/mock_pt\"\n    cat \u003e \"$mock_pt\" \u003c\u003c 'EOF'\n#!/usr/bin/env bash\nVERSION=\"1.2.3\"\nEOF\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\n# Should request specific version, not latest\nif [[ \"\\$*\" == *\"1.2.3\"* ]]; then\n    cat \"$mock_pt\"\n    exit 0\nelse\n    exit 1\nfi\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n    use_mock_bin\n    \n    test_info \"Running installer with PT_VERSION=1.2.3\"\n    run bash \"$INSTALL_SCRIPT\"\n    \n    # Verify correct version installed\n    if [[ -f \"${INSTALL_DIR}/pt\" ]]; then\n        local installed_version\n        installed_version=$(grep 'VERSION=' \"${INSTALL_DIR}/pt\" | cut -d'\"' -f2)\n        test_info \"Installed version: $installed_version\"\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n```\n\n## Success Criteria\n- [ ] Fresh install tested\n- [ ] Upgrade scenario tested\n- [ ] Checksum verification tested (pass and fail)\n- [ ] PATH management tested for bash/zsh\n- [ ] PT_NO_PATH option tested\n- [ ] Network failure handled gracefully\n- [ ] Specific version installation tested\n- [ ] All tests have detailed logging","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:49:13.558932389-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:49:13.558932389-05:00","dependencies":[{"issue_id":"process_triage-6xm","depends_on_id":"process_triage-h2y","type":"blocks","created_at":"2026-01-14T22:50:30.559722077-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-6xm","depends_on_id":"process_triage-ume","type":"blocks","created_at":"2026-01-14T22:50:30.603353657-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-7i0","title":"Add PATH management to installer","description":"## Purpose\nAutomatically add the installation directory to the user's PATH if not already present.\n\n## Parent Epic\nInstallation Infrastructure (process_triage-n0r)\n\n## Depends On\n- Add cross-platform mktemp and download functions\n\n## Shell Detection\n\n```bash\ndetect_shell() {\n    local shell_name\n    \n    # Check $SHELL environment variable\n    shell_name=\"${SHELL##*/}\"\n    \n    # Validate it's a known shell\n    case \"$shell_name\" in\n        bash|zsh|fish|sh)\n            echo \"$shell_name\"\n            ;;\n        *)\n            # Fallback: check what's running\n            if [[ -n \"${BASH_VERSION:-}\" ]]; then\n                echo \"bash\"\n            elif [[ -n \"${ZSH_VERSION:-}\" ]]; then\n                echo \"zsh\"\n            else\n                echo \"bash\"  # Default assumption\n            fi\n            ;;\n    esac\n}\n```\n\n## Shell Config Files\n\n```bash\nget_shell_config() {\n    local shell_name=\"$1\"\n    \n    case \"$shell_name\" in\n        bash)\n            # Prefer .bashrc for interactive, .bash_profile for login\n            if [[ -f \"$HOME/.bashrc\" ]]; then\n                echo \"$HOME/.bashrc\"\n            elif [[ -f \"$HOME/.bash_profile\" ]]; then\n                echo \"$HOME/.bash_profile\"\n            else\n                echo \"$HOME/.bashrc\"  # Create it\n            fi\n            ;;\n        zsh)\n            echo \"$HOME/.zshrc\"\n            ;;\n        fish)\n            echo \"$HOME/.config/fish/config.fish\"\n            ;;\n        *)\n            echo \"$HOME/.profile\"\n            ;;\n    esac\n}\n```\n\n## PATH Addition\n\n```bash\nadd_to_path() {\n    local install_dir=\"$1\"\n    \n    # Check if already in PATH\n    if [[ \":$PATH:\" == *\":$install_dir:\"* ]]; then\n        log_info \"$install_dir already in PATH\"\n        return 0\n    fi\n    \n    # Detect shell and config file\n    local shell_name config_file\n    shell_name=$(detect_shell)\n    config_file=$(get_shell_config \"$shell_name\")\n    \n    log_step \"Adding $install_dir to PATH in $config_file\"\n    \n    # Create directory for fish config if needed\n    if [[ \"$shell_name\" == \"fish\" ]]; then\n        mkdir -p \"${config_file%/*}\"\n    fi\n    \n    # Add PATH export (idempotent - check first)\n    local path_line\n    case \"$shell_name\" in\n        fish)\n            path_line=\"set -gx PATH \\\"$install_dir\\\" \\$PATH\"\n            ;;\n        *)\n            path_line=\"export PATH=\\\"$install_dir:\\$PATH\\\"\"\n            ;;\n    esac\n    \n    # Check if already added (avoid duplicates)\n    if [[ -f \"$config_file\" ]] \u0026\u0026 grep -qF \"$install_dir\" \"$config_file\"; then\n        log_info \"PATH already configured in $config_file\"\n        return 0\n    fi\n    \n    # Add to config\n    {\n        echo \"\"\n        echo \"# Added by pt installer\"\n        echo \"$path_line\"\n    } \u003e\u003e \"$config_file\"\n    \n    log_success \"Added to $config_file\"\n    log_info \"Run 'source $config_file' or start a new terminal.\"\n}\n```\n\n## Skip Option\n\n```bash\n# In main():\nif [[ \"${PT_NO_PATH:-}\" \\!= \"1\" ]]; then\n    add_to_path \"$install_dir\"\nelse\n    log_info \"Skipping PATH modification (PT_NO_PATH=1)\"\nfi\n```\n\n## Success Criteria\n- [ ] Detects bash, zsh, fish correctly\n- [ ] Uses correct config file for each shell\n- [ ] Doesn't add duplicates\n- [ ] Creates fish config directory if needed\n- [ ] PT_NO_PATH=1 skips PATH modification\n- [ ] Clear instructions to activate changes","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:36:32.47100567-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:36:32.47100567-05:00","dependencies":[{"issue_id":"process_triage-7i0","depends_on_id":"process_triage-c57","type":"blocks","created_at":"2026-01-14T22:40:45.552787909-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-7ku","title":"Create release.yml workflow","description":"## Purpose\nCreate the release workflow that triggers on version tags and creates GitHub releases with all artifacts.\n\n## Parent Epic\nRelease Automation with Checksums (process_triage-aip)\n\n## Depends On\n- Create VERSION file as single source of truth\n- Create ci.yml with ShellCheck job (CI must exist first)\n\n## Trigger Configuration\n```yaml\non:\n  push:\n    tags:\n      - 'v*'  # v1.0.0, v1.2.3, etc.\n```\n\n## Implementation\n\n### .github/workflows/release.yml\n```yaml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\npermissions:\n  contents: write  # Needed to create releases\n\njobs:\n  release:\n    name: Create Release\n    runs-on: ubuntu-latest\n    \n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Extract version from tag\n        id: version\n        run: |\n          # Tag is refs/tags/v1.2.3 → extract 1.2.3\n          tag_version=${GITHUB_REF#refs/tags/v}\n          echo \"version=$tag_version\" \u003e\u003e $GITHUB_OUTPUT\n          echo \"Releasing version: $tag_version\"\n      \n      - name: Validate version matches script\n        run: |\n          tag_version=\"${{ steps.version.outputs.version }}\"\n          script_version=$(grep '^VERSION=' pt | head -1 | cut -d'\"' -f2)\n          \n          if [[ \"$tag_version\" \\!= \"$script_version\" ]]; then\n            echo \"::error::Tag version ($tag_version) doesn't match script version ($script_version)\"\n            echo \"\"\n            echo \"To fix: Update VERSION constant in pt to $tag_version\"\n            exit 1\n          fi\n          \n          echo \"✓ Version validated: $tag_version\"\n      \n      - name: Generate checksums\n        run: |\n          # Combined checksums file\n          sha256sum pt install.sh \u003e checksums.sha256\n          \n          # Individual checksum files (for installer)\n          sha256sum pt | tee pt.sha256\n          sha256sum install.sh | tee install.sh.sha256\n          \n          echo \"\"\n          echo \"Generated checksums:\"\n          cat checksums.sha256\n      \n      - name: Create Release\n        uses: softprops/action-gh-release@v1\n        with:\n          name: \"pt v${{ steps.version.outputs.version }}\"\n          draft: false\n          prerelease: false\n          files: |\n            pt\n            install.sh\n            checksums.sha256\n            pt.sha256\n            install.sh.sha256\n          body: |\n            ## Installation\n            \n            \\`\\`\\`bash\n            curl -fsSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | bash\n            \\`\\`\\`\n            \n            ### With checksum verification\n            \\`\\`\\`bash\n            VERIFY=1 curl -fsSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | bash\n            \\`\\`\\`\n            \n            ## Manual Verification\n            \\`\\`\\`bash\n            # Download\n            curl -fsSL https://github.com/${{ github.repository }}/releases/download/v${{ steps.version.outputs.version }}/pt -o pt\n            \n            # Verify checksum\n            echo \"$(curl -fsSL https://github.com/${{ github.repository }}/releases/download/v${{ steps.version.outputs.version }}/pt.sha256)\" | sha256sum -c -\n            \n            # Install\n            chmod +x pt \u0026\u0026 mv pt ~/.local/bin/\n            \\`\\`\\`\n            \n            ## What's New\n            \n            See [CHANGELOG](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n## Release Process (for developers)\n```bash\n# 1. Update VERSION in pt script\n# 2. Update VERSION file\n# 3. Commit changes\ngit add -A \u0026\u0026 git commit -m \"Bump version to 1.1.0\"\n\n# 4. Create and push tag\ngit tag v1.1.0\ngit push origin main --tags\n\n# 5. GitHub Action automatically:\n#    - Validates version\n#    - Generates checksums\n#    - Creates release with artifacts\n```\n\n## Success Criteria\n- [ ] release.yml created\n- [ ] Triggers on v* tags\n- [ ] Version validation prevents mismatches\n- [ ] Checksums generated correctly\n- [ ] Release created with all artifacts\n- [ ] Release notes include install instructions","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:39:21.422180653-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:39:21.422180653-05:00","dependencies":[{"issue_id":"process_triage-7ku","depends_on_id":"process_triage-nk1","type":"blocks","created_at":"2026-01-14T22:40:47.995394333-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-7ku","depends_on_id":"process_triage-i5r","type":"blocks","created_at":"2026-01-14T22:40:48.059595257-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-82j","title":"Implement HTTP redirect-based version checking","description":"## Purpose\nImplement version checking that uses HTTP redirects instead of GitHub API, avoiding rate limits and proxy issues.\n\n## Parent Epic\nSelf-Update Mechanism (process_triage-097)\n\n## Depends On\n- Create VERSION file as single source of truth\n\n## Why Not GitHub API?\nFrom repo_updater's design rationale:\n1. **Rate Limits**: GitHub API has strict rate limits for unauthenticated requests\n2. **Proxy Issues**: Corporate proxies often block API calls but allow web traffic\n3. **Simplicity**: Redirect probing is simpler with fewer failure modes\n4. **No Auth Needed**: Works without tokens\n\n## Implementation\n\n### The Redirect Trick\nGitHub's `/releases/latest` redirects to the actual release URL:\n```\nhttps://github.com/USER/REPO/releases/latest\n  → 302 Redirect →\nhttps://github.com/USER/REPO/releases/tag/v1.2.3\n```\n\nWe can extract the version from the final URL.\n\n### Code Implementation\n```bash\n#------------------------------------------------------------------------------\n# Version checking (no GitHub API needed)\n#------------------------------------------------------------------------------\n\nGITHUB_REPO=\"Dicklesworthstone/process_triage\"\nRELEASES_URL=\"https://github.com/${GITHUB_REPO}/releases\"\n\nget_latest_version() {\n    local effective_url\n    \n    # Follow redirects and get final URL\n    # -o /dev/null: discard body\n    # -w '%{url_effective}': print final URL\n    # -L: follow redirects\n    # --connect-timeout: don't hang forever\n    effective_url=$(curl -fsSL -o /dev/null -w '%{url_effective}' \\\n        --connect-timeout 5 --max-time 10 \\\n        \"${RELEASES_URL}/latest\" 2\u003e/dev/null)\n    \n    if [[ -z \"$effective_url\" ]]; then\n        log_debug \"Could not fetch latest release URL\"\n        return 1\n    fi\n    \n    # Extract version from URL: .../releases/tag/v1.2.3 → 1.2.3\n    local version=\"${effective_url##*/}\"  # Get last path component\n    version=\"${version#v}\"                 # Remove 'v' prefix if present\n    \n    if [[ \\! \"$version\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n        log_debug \"Invalid version format: $version\"\n        return 1\n    fi\n    \n    printf '%s' \"$version\"\n}\n\ncheck_for_update() {\n    local current=\"$VERSION\"\n    local latest\n    \n    latest=$(get_latest_version) || {\n        log_debug \"Could not check for updates\"\n        return 1\n    }\n    \n    if version_gt \"$latest\" \"$current\"; then\n        printf '%s' \"$latest\"\n        return 0\n    else\n        return 1  # No update available\n    fi\n}\n\n# Semantic version comparison\nversion_gt() {\n    local v1=\"$1\" v2=\"$2\"\n    \n    # Use sort -V if available (GNU coreutils)\n    if printf '%s\\n' \"$v1\" \"$v2\" | sort -V \u0026\u003e/dev/null; then\n        [[ \"$(printf '%s\\n' \"$v1\" \"$v2\" | sort -V | tail -n1)\" == \"$v1\" \u0026\u0026 \"$v1\" \\!= \"$v2\" ]]\n    else\n        # Fallback: simple string comparison (works for most cases)\n        [[ \"$v1\" \u003e \"$v2\" ]]\n    fi\n}\n```\n\n### Usage in Update Command\n```bash\ncmd_update() {\n    local check_only=false\n    [[ \"${1:-}\" == \"--check\" ]] \u0026\u0026 check_only=true\n    \n    log_step \"Checking for updates...\"\n    \n    local latest\n    if latest=$(check_for_update); then\n        log_info \"Update available: ${VERSION} → ${latest}\"\n        \n        if [[ \"$check_only\" == \"true\" ]]; then\n            return 0\n        fi\n        \n        # Continue with download and install...\n    else\n        log_success \"Already on latest version ($VERSION)\"\n        return 0\n    fi\n}\n```\n\n## Error Handling\n- Network timeout: Return gracefully, don't block user\n- Invalid URL: Log debug message, return error\n- Invalid version format: Log debug, return error\n\n## Success Criteria\n- [ ] Version check works without GitHub API\n- [ ] Handles network timeouts gracefully\n- [ ] Extracts version correctly from redirect URL\n- [ ] version_gt() compares semver correctly\n- [ ] Works through corporate proxies","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:35:01.53043535-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:35:01.53043535-05:00","dependencies":[{"issue_id":"process_triage-82j","depends_on_id":"process_triage-nk1","type":"blocks","created_at":"2026-01-14T22:40:44.531713761-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-8ng","title":"Add section markers and reorganize code","description":"## Purpose\nAdd clear section markers to pt script and reorganize functions following the patterns from repo_updater.\n\n## Parent Epic\nCode Organization \u0026 Standards (process_triage-a6q)\n\n## Current Structure (pt - 579 lines)\nThe script has implicit sections but no clear markers:\n- Lines 1-29: Version and config\n- Lines 35-64: ensure_gum()\n- Lines 70-95: Utility functions\n- etc.\n\n## Target Structure with Section Markers\n\n```bash\n#\\!/usr/bin/env bash\n#\n# pt - Process Triage\n# Interactive zombie/abandoned process killer\n#\n# https://github.com/Dicklesworthstone/process_triage\n#\n\n#==============================================================================\n# SECTION 1: VERSION AND CONSTANTS\n#==============================================================================\n\nVERSION=\"1.0.0\"\nGITHUB_REPO=\"Dicklesworthstone/process_triage\"\n\n#------------------------------------------------------------------------------\n# Scoring thresholds\n#------------------------------------------------------------------------------\n\nTHRESHOLD_KILL=50\nTHRESHOLD_REVIEW=20\n\n#==============================================================================\n# SECTION 2: CONFIGURATION\n#==============================================================================\n\n#------------------------------------------------------------------------------\n# XDG Base Directory paths\n#------------------------------------------------------------------------------\n\nXDG_CONFIG_HOME=\"${XDG_CONFIG_HOME:-$HOME/.config}\"\nCONFIG_DIR=\"${PROCESS_TRIAGE_CONFIG:-$XDG_CONFIG_HOME/process_triage}\"\nDECISIONS_FILE=\"$CONFIG_DIR/decisions.json\"\nLOG_FILE=\"$CONFIG_DIR/triage.log\"\n\n#==============================================================================\n# SECTION 3: TERMINAL DETECTION AND COLORS\n#==============================================================================\n\n#------------------------------------------------------------------------------\n# TTY and color detection\n#------------------------------------------------------------------------------\n\nIS_TTY=false\n[[ -t 2 ]] \u0026\u0026 IS_TTY=true\n\nUSE_COLOR=true\nif [[ \"$IS_TTY\" \\!= \"true\" ]] || [[ -n \"${NO_COLOR:-}\" ]]; then\n    USE_COLOR=false\nfi\n\n#------------------------------------------------------------------------------\n# ANSI color codes\n#------------------------------------------------------------------------------\n\nif [[ \"$USE_COLOR\" == \"true\" ]]; then\n    RED='\\033[0;31m'\n    # ... etc\nfi\n\n#==============================================================================\n# SECTION 4: LOGGING FUNCTIONS\n#==============================================================================\n\nlog_info() { ... }\nlog_success() { ... }\nlog_warn() { ... }\nlog_error() { ... }\nlog_step() { ... }\nlog_debug() { ... }\n\n#==============================================================================\n# SECTION 5: UTILITY FUNCTIONS\n#==============================================================================\n\nformat_duration() { ... }\nformat_memory() { ... }\n\n#==============================================================================\n# SECTION 6: DEPENDENCY MANAGEMENT\n#==============================================================================\n\nensure_gum() { ... }\nensure_config() { ... }\n\n#==============================================================================\n# SECTION 7: GUM WRAPPERS (with ANSI fallback)\n#==============================================================================\n\ngum_style() { ... }\ngum_confirm() { ... }\ngum_choose() { ... }\ngum_spin() { ... }\n\n#==============================================================================\n# SECTION 8: DECISION MEMORY\n#==============================================================================\n\nnormalize_pattern() { ... }\nsave_decision() { ... }\nget_past_decision() { ... }\nload_decisions_cache() { ... }\nget_cached_decision() { ... }\n\n#==============================================================================\n# SECTION 9: PROCESS SCORING\n#==============================================================================\n\nscore_process() { ... }\n\n#==============================================================================\n# SECTION 10: PROCESS COLLECTION\n#==============================================================================\n\ncollect_candidates() { ... }\n\n#==============================================================================\n# SECTION 11: UI COMPONENTS\n#==============================================================================\n\nshow_header() { ... }\nshow_system_stats() { ... }\nformat_row() { ... }\n\n#==============================================================================\n# SECTION 12: COMMAND HANDLERS\n#==============================================================================\n\ncmd_scan() { ... }\ncmd_run() { ... }\ncmd_history() { ... }\ncmd_clear() { ... }\ncmd_update() { ... }\ncmd_help() { ... }\n\n#==============================================================================\n# SECTION 13: SELF-UPDATE\n#==============================================================================\n\nget_latest_version() { ... }\ncheck_for_update() { ... }\nverify_checksum() { ... }\nvalidate_script() { ... }\natomic_replace() { ... }\ndo_update() { ... }\n\n#==============================================================================\n# SECTION 14: ENTRY POINT\n#==============================================================================\n\nmain() { ... }\n\nmain \"$@\"\n```\n\n## Benefits\n1. **Navigation**: Jump to sections by searching for \"SECTION N\"\n2. **Understanding**: Clear boundaries between concerns\n3. **Maintenance**: Easy to find where to add new code\n4. **Documentation**: Self-documenting structure\n\n## Success Criteria\n- [ ] All sections have clear markers\n- [ ] Subsections have dashed markers\n- [ ] Functions grouped logically\n- [ ] No orphan code between sections\n- [ ] Section numbers are sequential","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:40:15.844282709-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:40:15.844282709-05:00"}
{"id":"process_triage-9ch","title":"Add BATS test job with matrix build","description":"## Purpose\nAdd a CI job that runs BATS tests on both Linux and macOS to ensure cross-platform compatibility.\n\n## Parent Epic\nGitHub Actions CI/CD Pipeline (process_triage-68c)\n\n## Depends On\n- Add bash syntax validation job to CI\n\n## Why Matrix Build?\n- pt should work on both Linux and macOS\n- Some bash features differ between GNU (Linux) and BSD (macOS)\n- macOS ships with bash 3.2 by default (we need 4.0+)\n\n## Implementation\n\n### Add to ci.yml\n```yaml\n  tests:\n    name: Tests (${{ matrix.os }})\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-latest, macos-latest]\n    \n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Install Bash 5 (macOS)\n        if: runner.os == 'macOS'\n        run: |\n          brew install bash\n          echo \"/opt/homebrew/bin\" \u003e\u003e $GITHUB_PATH\n          # Verify version\n          /opt/homebrew/bin/bash --version\n      \n      - name: Install BATS\n        run: |\n          git clone --depth 1 https://github.com/bats-core/bats-core.git\n          cd bats-core\n          sudo ./install.sh /usr/local\n      \n      - name: Install gum (for integration tests)\n        run: |\n          if [[ \"$RUNNER_OS\" == \"Linux\" ]]; then\n            sudo mkdir -p /etc/apt/keyrings\n            curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg\n            echo \"deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *\" | sudo tee /etc/apt/sources.list.d/charm.list\n            sudo apt update \u0026\u0026 sudo apt install -y gum\n          else\n            brew install gum\n          fi\n        continue-on-error: true  # Tests should work without gum too\n      \n      - name: Run BATS tests\n        run: |\n          bats --tap test/\n        env:\n          TERM: xterm-256color\n      \n      - name: Upload test results\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: test-results-${{ matrix.os }}\n          path: test/\n          retention-days: 14\n```\n\n## macOS Bash Version Issue\nmacOS ships with bash 3.2 (ancient, from 2007) due to licensing.\nWe need bash 4.0+ for:\n- Associative arrays (`declare -A`)\n- `mapfile` / `readarray`\n- Various modern features\n\nSolution: Install bash 5 via Homebrew on macOS runners.\n\n## Success Criteria\n- [ ] Tests run on ubuntu-latest\n- [ ] Tests run on macos-latest\n- [ ] Bash 5 installed on macOS\n- [ ] BATS installed and working\n- [ ] Test results uploaded as artifacts\n- [ ] Tests pass on both platforms","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:37:31.856147324-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:37:31.856147324-05:00","dependencies":[{"issue_id":"process_triage-9ch","depends_on_id":"process_triage-omq","type":"blocks","created_at":"2026-01-14T22:40:46.309822855-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-9jo","title":"Add structured error messages with remediation","description":"## Purpose\nAdd a consistent error message format that includes the problem and a suggested fix.\n\n## Parent Epic\nCode Organization \u0026 Standards (process_triage-a6q)\n\n## Depends On\n- Implement log_* functions with emoji prefixes\n\n## Current State\n```bash\nlog_error \"Failed to install gum\"\n# User doesn't know what to do next\n```\n\n## Target State\n```bash\nerror_with_fix \"gum installation failed\" \\\n    \"Package manager not found or installation rejected\" \\\n    \"Install gum manually: brew install gum (or apt install gum)\"\n\n# Output:\n# ✗ gum installation failed\n#   Reason: Package manager not found or installation rejected\n#   Fix: Install gum manually: brew install gum (or apt install gum)\n```\n\n## Implementation\n\n### Error Functions\n```bash\n#------------------------------------------------------------------------------\n# Structured error messages\n#------------------------------------------------------------------------------\n\n# Full error with reason and fix\nerror_with_fix() {\n    local category=\"$1\"\n    local reason=\"$2\"\n    local fix=\"$3\"\n    \n    log_error \"$category\"\n    printf '  %bReason:%b %s\\n' \"$DIM\" \"$RESET\" \"$reason\" \u003e\u00262\n    printf '  %bFix:%b %s\\n' \"$DIM\" \"$RESET\" \"$fix\" \u003e\u00262\n}\n\n# Error with just a fix suggestion\nerror_with_hint() {\n    local message=\"$1\"\n    local hint=\"$2\"\n    \n    log_error \"$message\"\n    printf '  %bHint:%b %s\\n' \"$DIM\" \"$RESET\" \"$hint\" \u003e\u00262\n}\n\n# Error for permission issues\nerror_permission() {\n    local path=\"$1\"\n    local action=\"${2:-write to}\"\n    \n    error_with_fix \"Permission denied\" \\\n        \"Cannot $action $path\" \\\n        \"Try with sudo, or use a different location\"\n}\n\n# Error for missing dependency\nerror_missing_dep() {\n    local dep=\"$1\"\n    local install_cmd=\"$2\"\n    \n    error_with_fix \"$dep not found\" \\\n        \"$dep is required but not installed\" \\\n        \"Install it with: $install_cmd\"\n}\n```\n\n### Usage Examples\n```bash\n# Network error\nerror_with_fix \"Update check failed\" \\\n    \"Could not reach GitHub (timeout or DNS)\" \\\n    \"Check your internet connection and try again\"\n\n# Permission error\nerror_permission \"/usr/local/bin/pt\" \"write to\"\n\n# Missing dependency\nerror_missing_dep \"jq\" \"apt install jq (or brew install jq)\"\n\n# Version mismatch\nerror_with_hint \"Version mismatch\" \\\n    \"Update the VERSION file to match the script, or vice versa\"\n```\n\n## Migration\nReplace all bare log_error calls with structured errors where a fix is possible:\n```bash\n# Before\nlog_error \"Download failed\"\n\n# After\nerror_with_fix \"Download failed\" \\\n    \"Network request timed out after 30 seconds\" \\\n    \"Check your connection and try: pt update --force\"\n```\n\n## Success Criteria\n- [ ] error_with_fix function implemented\n- [ ] error_with_hint function implemented\n- [ ] Convenience functions for common errors\n- [ ] All actionable errors include remediation\n- [ ] Consistent formatting across all errors","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:40:17.037471047-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:40:17.037471047-05:00","dependencies":[{"issue_id":"process_triage-9jo","depends_on_id":"process_triage-vpb","type":"blocks","created_at":"2026-01-14T22:40:50.714269143-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-a50","title":"Add 'pt update' command to CLI","description":"## Purpose\nAdd the update command to pt's CLI interface, integrating all the update infrastructure.\n\n## Parent Epic\nSelf-Update Mechanism (process_triage-097)\n\n## Depends On\n- Implement atomic file replacement (final step in chain)\n\n## CLI Interface\n\n### Commands\n```bash\npt update           # Check and install updates\npt update --check   # Check only, don't install\npt update --force   # Update even if on latest version (re-install)\n```\n\n### Help Text Addition\n```\n  update          Check for and install updates\n    --check       Check only, don't install\n    --force       Force re-installation of current version\n```\n\n## Implementation\n\n### Command Handler\n```bash\ncmd_update() {\n    local check_only=false\n    local force=false\n    \n    # Parse arguments\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            --check|-c)\n                check_only=true\n                shift\n                ;;\n            --force|-f)\n                force=true\n                shift\n                ;;\n            *)\n                log_error \"Unknown option: $1\"\n                return 1\n                ;;\n        esac\n    done\n    \n    show_header\n    \n    log_step \"Checking for updates...\"\n    \n    local latest\n    if latest=$(check_for_update); then\n        log_info \"Update available: ${VERSION} → ${latest}\"\n        \n        if [[ \"$check_only\" == \"true\" ]]; then\n            log_info \"Run 'pt update' to install.\"\n            return 0\n        fi\n        \n        # Confirm update\n        if [[ \"$IS_TTY\" == \"true\" ]]; then\n            if \\! gum_confirm \"Install update?\"; then\n                log_info \"Update cancelled.\"\n                return 0\n            fi\n        fi\n        \n        # Do the update\n        do_update \"$latest\"\n        \n    elif [[ \"$force\" == \"true\" ]]; then\n        log_info \"Forcing re-installation of v${VERSION}\"\n        do_update \"$VERSION\"\n        \n    else\n        log_success \"Already on latest version ($VERSION)\"\n    fi\n}\n```\n\n### Integration in Main\n```bash\nmain() {\n    ensure_gum\n    ensure_config\n    \n    case \"${1:-}\" in\n        run|\"\")      shift 2\u003e/dev/null || true; cmd_run \"$@\" ;;\n        scan)         shift; cmd_scan \"$@\" ;;\n        history)      shift; cmd_history \"$@\" ;;\n        clear)        shift; cmd_clear \"$@\" ;;\n        update)       shift; cmd_update \"$@\" ;;  # ← Add this\n        help|-h|--help)\n            cmd_help\n            ;;\n        version|-v|--version)\n            printf 'pt version %s\\n' \"$VERSION\"\n            ;;\n        *)\n            log_error \"Unknown command: $1\"\n            log_info \"Run 'pt help' for usage.\"\n            exit 1\n            ;;\n    esac\n}\n```\n\n### Update Output Example\n```\n╭─────────────────────────────────────────────╮\n│  Process Triage v1.0.0                      │\n╰─────────────────────────────────────────────╯\n\n→ Checking for updates...\nℹ Update available: 1.0.0 → 1.1.0\n\nInstall update? [Y/n] y\n\n→ Downloading pt v1.1.0...\n✓ Checksum verified: a3f2b8c9d4e5...\n✓ Script validation passed\n→ Installing update...\n✓ Updated to pt v1.1.0\n\nℹ Run 'pt --version' to verify.\n```\n\n## Error Cases\n- Network error: \"Could not check for updates. Check your connection.\"\n- Checksum mismatch: \"Update aborted: checksum verification failed\"\n- Permission denied: \"Cannot write to /path. Try with sudo.\"\n- Syntax invalid: \"Downloaded file failed validation, aborting\"\n\n## Success Criteria\n- [ ] `pt update` checks and installs\n- [ ] `pt update --check` only checks\n- [ ] `pt update --force` re-installs current version\n- [ ] Clear progress messages\n- [ ] Graceful error handling\n- [ ] Non-interactive mode works (no prompts)","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:36:30.202582141-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:36:30.202582141-05:00","dependencies":[{"issue_id":"process_triage-a50","depends_on_id":"process_triage-or6","type":"blocks","created_at":"2026-01-14T22:40:44.705233949-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-a50","depends_on_id":"process_triage-82j","type":"blocks","created_at":"2026-01-14T22:52:21.603008448-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-a50","depends_on_id":"process_triage-4ps","type":"blocks","created_at":"2026-01-14T22:52:21.646799818-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-a50","depends_on_id":"process_triage-3v6","type":"blocks","created_at":"2026-01-14T22:52:21.691273765-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-a6q","title":"Code Organization \u0026 Standards","description":"## Overview\nRefactor pt to follow the code organization and standards patterns established in repo_updater and giil.\n\n## Current State\n- pt is 579 lines with minimal section organization\n- No clear section markers\n- Function naming is inconsistent\n- Exit codes are not well-defined\n- Error messages lack remediation hints\n\n## Target State\nClean, well-organized codebase with:\n1. Clear section markers\n2. Semantic function naming\n3. Defined exit codes\n4. Structured error messages\n5. XDG compliance improvements\n\n## Section Marker Pattern (from repo_updater)\n```bash\n#==============================================================================\n# SECTION 1: VERSION AND CONSTANTS\n#==============================================================================\n\nVERSION=\"1.0.0\"\nGITHUB_REPO=\"Dicklesworthstone/process_triage\"\n\n#------------------------------------------------------------------------------\n# Configuration paths\n#------------------------------------------------------------------------------\n\nCONFIG_DIR=\"${PROCESS_TRIAGE_CONFIG:-${XDG_CONFIG_HOME:-$HOME/.config}/process_triage}\"\n\n#==============================================================================\n# SECTION 2: ANSI COLOR DEFINITIONS\n#==============================================================================\n# ...\n```\n\n## Semantic Function Naming Convention\n| Prefix | Purpose | Example |\n|--------|---------|---------|\n| cmd_* | CLI command handlers | cmd_scan, cmd_run, cmd_update |\n| log_* | Logging functions | log_info, log_error, log_warn |\n| ensure_* | Dependency checks | ensure_gum, ensure_config |\n| format_* | Output formatting | format_duration, format_row |\n| gum_* | Gum wrappers | gum_confirm, gum_choose |\n\n## Exit Code Scheme\n```bash\n# Success\nEXIT_SUCCESS=0\n\n# User/usage errors (1-9)\nEXIT_USAGE_ERROR=1        # Bad CLI arguments\nEXIT_NO_CANDIDATES=2      # No processes to review\n\n# Dependency errors (10-19)\nEXIT_MISSING_GUM=10       # gum not installed and can't auto-install\nEXIT_MISSING_JQ=11        # jq not available (optional, warn only)\n\n# Operation errors (20-29)\nEXIT_KILL_FAILED=20       # Some processes couldn't be killed\nEXIT_PERMISSION=21        # Permission denied\n\n# Update errors (30-39)\nEXIT_UPDATE_FAILED=30     # Self-update failed\nEXIT_CHECKSUM_MISMATCH=31 # Downloaded file failed verification\n\n# Internal errors (90+)\nEXIT_INTERNAL=90          # Bug in pt\n```\n\n## Structured Error Messages (from giil pattern)\n```bash\nerror_with_fix() {\n    local category=\"$1\"\n    local reason=\"$2\"\n    local fix=\"$3\"\n    \n    log_error \"$category\"\n    printf '  Reason: %s\\n' \"$reason\" \u003e\u00262\n    printf '  Fix: %s\\n' \"$fix\" \u003e\u00262\n}\n\n# Usage:\nerror_with_fix \"Permission denied\" \\\n    \"Cannot write to /usr/local/bin\" \\\n    \"Run with sudo or install to ~/.local/bin\"\n```\n\n## XDG Compliance (Current vs Target)\n\n### Current\n```bash\nCONFIG_DIR=\"${PROCESS_TRIAGE_CONFIG:-${XDG_CONFIG_HOME:-$HOME/.config}/process_triage}\"\n```\n\n### Target (more robust)\n```bash\n# Resolve with validation\nresolve_xdg_path() {\n    local var=\"$1\"\n    local default=\"$2\"\n    local value=\"${\\!var:-}\"\n    \n    if [[ -n \"$value\" ]]; then\n        # Validate it's an absolute path\n        if [[ \"$value\" \\!= /* ]]; then\n            log_warn \"$var must be absolute path, using default\"\n            value=\"$default\"\n        fi\n    else\n        value=\"$default\"\n    fi\n    \n    echo \"$value\"\n}\n\nXDG_CONFIG_HOME=\"$(resolve_xdg_path XDG_CONFIG_HOME \"$HOME/.config\")\"\nXDG_STATE_HOME=\"$(resolve_xdg_path XDG_STATE_HOME \"$HOME/.local/state\")\"\nXDG_CACHE_HOME=\"$(resolve_xdg_path XDG_CACHE_HOME \"$HOME/.cache\")\"\n\nCONFIG_DIR=\"$XDG_CONFIG_HOME/process_triage\"\nSTATE_DIR=\"$XDG_STATE_HOME/process_triage\"   # For logs\nCACHE_DIR=\"$XDG_CACHE_HOME/process_triage\"   # For temp files\n```\n\n## set -uo pipefail (NOT set -e)\nFrom repo_updater's rationale:\n```bash\nset -uo pipefail  # NOT set -e because:\n# 1. output=$(failing_cmd); exit_code=$? would exit before capturing exit_code\n# 2. repos must continue processing after individual failures\n# 3. Explicit error handling is more predictable\n```\n\n## Success Criteria\n- [ ] Clear section markers for all code regions\n- [ ] Consistent function naming with semantic prefixes\n- [ ] Defined exit codes for all error conditions\n- [ ] Error messages include remediation hints\n- [ ] Full XDG Base Directory compliance\n- [ ] Code passes ShellCheck with no warnings","status":"open","priority":2,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:32:45.552785018-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:32:45.552785018-05:00"}
{"id":"process_triage-aip","title":"Release Automation with Checksums","description":"## Overview\nImplement automated release workflow that generates checksums and creates GitHub releases with all artifacts.\n\n## Current State\n- No release automation\n- No checksums generated\n- Manual release process (if any)\n- No verification infrastructure for users\n\n## Target State\nAutomated release on git tag push:\n```bash\ngit tag v1.1.0\ngit push origin v1.1.0\n# → GitHub Action creates release with all artifacts\n```\n\n## release.yml Structure\n\n### Trigger\n```yaml\non:\n  push:\n    tags:\n      - 'v*'  # Triggers on v1.0.0, v1.2.3, etc.\n```\n\n### Steps\n\n#### 1. Version Validation\n```yaml\n- name: Validate version\n  run: |\n    tag_version=${GITHUB_REF#refs/tags/v}\n    script_version=$(grep '^VERSION=' pt | cut -d= -f2 | tr -d '\"')\n    if [[ \"$tag_version\" \\!= \"$script_version\" ]]; then\n      echo \"Tag ($tag_version) doesn't match script ($script_version)\"\n      exit 1\n    fi\n```\n\n#### 2. Checksum Generation\n```yaml\n- name: Generate checksums\n  run: |\n    sha256sum pt install.sh \u003e checksums.sha256\n    sha256sum pt \u003e pt.sha256\n    sha256sum install.sh \u003e install.sh.sha256\n    cat checksums.sha256\n```\n\n#### 3. Create Release\n```yaml\n- name: Create GitHub Release\n  uses: softprops/action-gh-release@v1\n  with:\n    files: |\n      pt\n      install.sh\n      checksums.sha256\n      pt.sha256\n      install.sh.sha256\n    body: |\n      ## Installation\n      \\`\\`\\`bash\n      curl -fsSL https://raw.githubusercontent.com/.../install.sh | bash\n      \\`\\`\\`\n      \n      ## Verification\n      \\`\\`\\`bash\n      echo \"$(curl -fsSL .../pt.sha256)  pt\" | sha256sum -c -\n      \\`\\`\\`\n```\n\n## Release Artifacts\n| File | Purpose |\n|------|---------|\n| pt | Main executable |\n| install.sh | Installation script |\n| checksums.sha256 | All checksums in one file |\n| pt.sha256 | Just pt checksum (for install.sh) |\n| install.sh.sha256 | Just installer checksum |\n\n## Why Individual Checksum Files?\n- **pt.sha256**: Used by install.sh for verification\n- **install.sh.sha256**: For users who want to verify installer\n- **checksums.sha256**: Combined file for convenience\n\n## Security Considerations\n- Checksums are generated in CI (not locally) for reproducibility\n- Tag must match script version (prevents accidental releases)\n- Users can verify before running: `curl ... | sha256sum -c -`\n\n## Success Criteria\n- [ ] Tags trigger release workflow\n- [ ] Version mismatch blocks release\n- [ ] All artifacts are uploaded\n- [ ] Checksums are correct and verifiable\n- [ ] Release notes include install/verify instructions","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:32:44.230616595-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:32:44.230616595-05:00"}
{"id":"process_triage-bgd","title":"Expanded Test Coverage","description":"## Overview\nSignificantly expand the BATS test suite to cover all major functionality and match the testing standards of repo_updater (70+ tests).\n\n## Current State\n- Only 8 basic tests in test/pt.bats\n- Tests cover: help, version, unknown command, scan, history, clear\n- NO tests for: scoring system, pattern normalization, decision memory, kill logic\n- No TAP output support documented\n- No mock injection patterns\n\n## Target State\nComprehensive test suite covering:\n1. **Unit tests**: Individual function testing\n2. **Integration tests**: Feature interaction testing\n3. **E2E tests**: Full workflow testing\n\n## Test Categories to Add\n\n### 1. Scoring System Tests\n```bash\n@test \"score_process: age \u003e 1 week gets +50\" {\n    # Test the scoring heuristics\n}\n\n@test \"score_process: orphaned process (PPID=1) gets +25\" {\n    # Test orphan detection\n}\n\n@test \"score_process: stuck test runner gets +40\" {\n    # Test pattern matching for bun test, jest, pytest\n}\n\n@test \"score_process: system service gets -200 (protected)\" {\n    # Test protection mechanism\n}\n```\n\n### 2. Pattern Normalization Tests\n```bash\n@test \"normalize_pattern: removes PIDs\" {\n    result=$(normalize_pattern \"node 12345 server.js\")\n    [[ \"$result\" != *\"12345\"* ]]\n}\n\n@test \"normalize_pattern: normalizes ports\" {\n    result=$(normalize_pattern \"--port=3000\")\n    [[ \"$result\" == *\"--port=PORT\"* ]]\n}\n\n@test \"normalize_pattern: normalizes UUIDs\" {\n    result=$(normalize_pattern \"abc-550e8400-e29b-41d4-a716-446655440000-xyz\")\n    [[ \"$result\" == *\"UUID\"* ]]\n}\n```\n\n### 3. Decision Memory Tests\n```bash\n@test \"save_decision: creates valid JSON\" {\n    save_decision \"kill\" \"test pattern\"\n    jq -e '.\"test pattern\"' \"$CONFIG_DIR/decisions.json\"\n}\n\n@test \"get_cached_decision: returns saved decision\" {\n    save_decision \"spare\" \"gunicorn\"\n    result=$(get_cached_decision \"gunicorn\")\n    [[ \"$result\" == \"spare\" ]]\n}\n```\n\n### 4. Process Collection Tests\n```bash\n@test \"collect_candidates: filters by minimum age\" {\n    # Mock ps output and verify filtering\n}\n\n@test \"collect_candidates: excludes system services\" {\n    # Verify systemd, sshd, etc. are excluded\n}\n```\n\n## Mock Injection Pattern (from repo_updater)\n```bash\nsetup() {\n    TEST_DIR=\"$(mktemp -d)\"\n    mkdir -p \"$TEST_DIR/mock_bin\"\n    \n    # Create mock ps command\n    cat \u003e \"$TEST_DIR/mock_bin/ps\" \u003c\u003c 'EOF'\n#!/bin/bash\necho \"12345|1|100000|512|bun test --watch\"\necho \"23456|1000|200000|1024|next dev\"\nEOF\n    chmod +x \"$TEST_DIR/mock_bin/ps\"\n}\n\n@test \"scoring with mocked ps\" {\n    PATH=\"$TEST_DIR/mock_bin:$PATH\" run pt scan\n    # Verify output\n}\n```\n\n## TAP Output Support\n```bash\n# Run with TAP output for CI\nbats --tap test/pt.bats\n\n# Example TAP output:\n# 1..8\n# ok 1 pt --help shows usage\n# ok 2 pt help shows usage\n# ...\n```\n\n## Conditional Skips\n```bash\n@test \"interactive mode requires gum\" {\n    if ! command -v gum \u0026\u003e/dev/null; then\n        skip \"gum not installed\"\n    fi\n    # Test interactive features\n}\n```\n\n## Test File Organization\n```\ntest/\n├── pt.bats              # Main test file (expanded)\n├── test_scoring.bats    # Scoring system tests\n├── test_patterns.bats   # Pattern normalization tests\n├── test_memory.bats     # Decision memory tests\n├── test_commands.bats   # CLI command tests\n└── test_helper/\n    └── common.bash      # Shared setup/teardown\n```\n\n## Success Criteria\n- [ ] 30+ tests covering all major functionality\n- [ ] All scoring heuristics have test coverage\n- [ ] Pattern normalization is thoroughly tested\n- [ ] Decision memory persistence is tested\n- [ ] Mock injection enables isolated testing\n- [ ] Tests pass on both Linux and macOS","status":"open","priority":2,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:32:44.489765064-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:32:44.489765064-05:00"}
{"id":"process_triage-c57","title":"Add cross-platform mktemp and download functions","description":"## Purpose\nImplement cross-platform utilities for temp directories and file downloads that work on both Linux and macOS.\n\n## Parent Epic\nInstallation Infrastructure (process_triage-n0r)\n\n## Depends On\n- Create install.sh with self-refresh mechanism\n\n## Cross-Platform mktemp\n\n### The Problem\n```bash\n# GNU mktemp (Linux) - works\nmktemp -d\n\n# BSD mktemp (macOS) - requires template\nmktemp -d          # May fail\nmktemp -d -t name  # Works\n```\n\n### Solution\n```bash\nmktemp_dir() {\n    local dir\n    \n    # Try GNU style first (Linux)\n    dir=$(mktemp -d 2\u003e/dev/null) \u0026\u0026 { echo \"$dir\"; return 0; }\n    \n    # BSD style with -t (macOS)\n    dir=$(mktemp -d -t pt 2\u003e/dev/null) \u0026\u0026 { echo \"$dir\"; return 0; }\n    \n    # BSD style with explicit template\n    dir=$(mktemp -d -t pt.XXXXXXXXXX 2\u003e/dev/null) \u0026\u0026 { echo \"$dir\"; return 0; }\n    \n    # Manual fallback\n    dir=\"/tmp/pt.$$.$(date +%s)\"\n    mkdir -p \"$dir\" \u0026\u0026 { echo \"$dir\"; return 0; }\n    \n    log_error \"Failed to create temporary directory\"\n    return 1\n}\n```\n\n## Download Function\n\n### Support Both curl and wget\n```bash\ndownload() {\n    local url=\"$1\"\n    local output=\"$2\"\n    \n    if command -v curl \u0026\u003e/dev/null; then\n        curl -fsSL --connect-timeout 10 --max-time 120 \"$url\" -o \"$output\"\n    elif command -v wget \u0026\u003e/dev/null; then\n        wget -q --timeout=10 -O \"$output\" \"$url\"\n    else\n        log_error \"Neither curl nor wget available\"\n        log_error \"Install curl: apt install curl (or brew install curl)\"\n        return 1\n    fi\n}\n```\n\n### Download with Progress (Optional)\n```bash\ndownload_with_progress() {\n    local url=\"$1\"\n    local output=\"$2\"\n    local description=\"${3:-Downloading}\"\n    \n    if [[ \"$GUM_AVAILABLE\" == \"true\" ]]; then\n        gum spin --spinner dot --title \"$description\" -- \\\n            curl -fsSL \"$url\" -o \"$output\"\n    else\n        log_step \"$description\"\n        download \"$url\" \"$output\"\n    fi\n}\n```\n\n## Cache-Busting\n\n### The Problem\nCDNs cache files. Fresh releases may not be immediately available.\n\n### Solution\n```bash\nappend_cache_buster() {\n    local url=\"$1\"\n    local timestamp=$(date +%s)\n    \n    if [[ \"$url\" == *\"?\"* ]]; then\n        echo \"${url}\u0026cb=${timestamp}\"\n    else\n        echo \"${url}?cb=${timestamp}\"\n    fi\n}\n\n# Usage\ndownload \"$(append_cache_buster \"$SCRIPT_URL\")\" \"$temp_file\"\n```\n\n## SHA256 Cross-Platform\n\n```bash\nsha256_file() {\n    local file=\"$1\"\n    \n    if command -v sha256sum \u0026\u003e/dev/null; then\n        sha256sum \"$file\" | cut -d' ' -f1\n    elif command -v shasum \u0026\u003e/dev/null; then\n        shasum -a 256 \"$file\" | cut -d' ' -f1\n    elif command -v openssl \u0026\u003e/dev/null; then\n        openssl dgst -sha256 \"$file\" | awk '{print $2}'\n    else\n        log_warn \"No SHA256 tool available\"\n        return 1\n    fi\n}\n```\n\n## Success Criteria\n- [ ] mktemp_dir works on Linux and macOS\n- [ ] download supports curl and wget\n- [ ] Cache-busting prevents stale downloads\n- [ ] SHA256 works on all platforms\n- [ ] Clear errors when tools unavailable","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:36:32.273129077-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:36:32.273129077-05:00","dependencies":[{"issue_id":"process_triage-c57","depends_on_id":"process_triage-ume","type":"blocks","created_at":"2026-01-14T22:40:45.41003931-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-ch7","title":"Add ANSI fallback when gum unavailable","description":"## Purpose\nImplement ANSI-based fallback UI when gum is not installed, ensuring pt works everywhere while looking best where possible.\n\n## Parent Epic\nConsole Output Styling Enhancement (process_triage-y8e)\n\n## Depends On\n- Add TTY detection and NO_COLOR support\n- Implement log_* functions with emoji prefixes\n\n## Current State\npt calls `ensure_gum()` which auto-installs gum. If installation fails:\n- Script exits with error\n- No graceful degradation\n\n## Target Behavior\n1. Try to use gum if available\n2. Fall back to ANSI if gum unavailable\n3. Fall back to plain text if no TTY\n\n## Implementation\n\n### 1. Wrapper Functions for Gum Features\n\n#### gum_style (banners, styled text)\n```bash\ngum_style() {\n    local text=\"$1\"\n    local border=\"${2:-rounded}\"\n    local color=\"${3:-212}\"\n    \n    if [[ \"$GUM_AVAILABLE\" == \"true\" ]]; then\n        gum style --border \"$border\" --border-foreground \"$color\" --padding \"0 2\" \"$text\"\n    else\n        # ANSI fallback - simple box\n        local width=$(( ${#text} + 4 ))\n        local border_line=\"$(printf '─%.0s' $(seq 1 $width))\"\n        printf '%b\\n' \"${MAGENTA}╭${border_line}╮${RESET}\"\n        printf '%b\\n' \"${MAGENTA}│${RESET}  $text  ${MAGENTA}│${RESET}\"\n        printf '%b\\n' \"${MAGENTA}╰${border_line}╯${RESET}\"\n    fi\n}\n```\n\n#### gum_confirm (yes/no prompts)\n```bash\ngum_confirm() {\n    local prompt=\"$1\"\n    local default=\"${2:-true}\"\n    \n    if [[ \"$GUM_AVAILABLE\" == \"true\" ]]; then\n        gum confirm \"$prompt\"\n        return $?\n    else\n        # ANSI fallback\n        local yn_prompt\n        if [[ \"$default\" == \"true\" ]]; then\n            yn_prompt=\"[Y/n]\"\n        else\n            yn_prompt=\"[y/N]\"\n        fi\n        \n        printf '%s %s ' \"$prompt\" \"$yn_prompt\" \u003e\u00262\n        local response\n        read -r response\n        \n        case \"${response,,}\" in\n            y|yes) return 0 ;;\n            n|no)  return 1 ;;\n            \"\")    [[ \"$default\" == \"true\" ]] \u0026\u0026 return 0 || return 1 ;;\n            *)     return 1 ;;\n        esac\n    fi\n}\n```\n\n#### gum_choose (multi-select)\n```bash\ngum_choose() {\n    local -a items=(\"$@\")\n    \n    if [[ \"$GUM_AVAILABLE\" == \"true\" ]]; then\n        printf '%s\\n' \"${items[@]}\" | gum choose --no-limit\n    else\n        # ANSI fallback - numbered list with manual selection\n        log_info \"Select items (space-separated numbers, or 'all'):\"\n        local i=1\n        for item in \"${items[@]}\"; do\n            printf '  %d) %s\\n' \"$i\" \"$item\" \u003e\u00262\n            ((i++))\n        done\n        \n        printf 'Selection: ' \u003e\u00262\n        local selection\n        read -r selection\n        \n        if [[ \"$selection\" == \"all\" ]]; then\n            printf '%s\\n' \"${items[@]}\"\n        else\n            for num in $selection; do\n                if [[ \"$num\" =~ ^[0-9]+$ ]] \u0026\u0026 (( num \u003e= 1 \u0026\u0026 num \u003c= ${#items[@]} )); then\n                    printf '%s\\n' \"${items[num-1]}\"\n                fi\n            done\n        fi\n    fi\n}\n```\n\n#### gum_spin (spinners)\n```bash\ngum_spin() {\n    local title=\"$1\"\n    shift\n    \n    if [[ \"$GUM_AVAILABLE\" == \"true\" ]]; then\n        gum spin --spinner dot --title \"$title\" -- \"$@\"\n    else\n        # ANSI fallback - just show message and run command\n        log_step \"$title\"\n        \"$@\"\n    fi\n}\n```\n\n### 2. Update ensure_gum() to be Optional\n```bash\nensure_gum() {\n    if command -v gum \u0026\u003e/dev/null; then\n        GUM_AVAILABLE=true\n        return 0\n    fi\n    \n    # Try to install, but don't fail if we can't\n    log_info \"gum not found, attempting to install for better UI...\"\n    \n    if install_gum 2\u003e/dev/null; then\n        GUM_AVAILABLE=true\n        log_success \"gum installed successfully\"\n    else\n        GUM_AVAILABLE=false\n        log_warn \"Could not install gum, using fallback UI\"\n    fi\n}\n```\n\n## Success Criteria\n- [ ] All gum features have ANSI fallbacks\n- [ ] pt works without gum installed\n- [ ] Fallback UI is functional (not just pretty)\n- [ ] Multi-select works in fallback mode\n- [ ] Confirmation prompts work in fallback mode","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:35:01.321160838-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:35:01.321160838-05:00","dependencies":[{"issue_id":"process_triage-ch7","depends_on_id":"process_triage-18z","type":"blocks","created_at":"2026-01-14T22:40:43.739406679-05:00","created_by":"Dicklesworthstone"},{"issue_id":"process_triage-ch7","depends_on_id":"process_triage-vpb","type":"blocks","created_at":"2026-01-14T22:40:43.772309983-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-dna","title":"Add version consistency check to CI","description":"## Purpose\nAdd a CI job that verifies the VERSION file matches the VERSION constant in the pt script.\n\n## Parent Epic\nGitHub Actions CI/CD Pipeline (process_triage-68c)\n\n## Depends On\n- Create VERSION file as single source of truth\n\n## Why This Check?\nCommon release bug: update VERSION file but forget to update script (or vice versa).\n- CI catches this before merge\n- Release workflow also checks this before publishing\n\n## Implementation\n\n### Add to ci.yml\n```yaml\n  version-check:\n    name: Version Consistency\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Check VERSION file exists\n        run: |\n          if [[ \\! -f VERSION ]]; then\n            echo \"::error::VERSION file not found\"\n            exit 1\n          fi\n      \n      - name: Verify version consistency\n        run: |\n          file_version=$(cat VERSION | tr -d '\\n')\n          script_version=$(grep '^VERSION=' pt | head -1 | cut -d'\"' -f2)\n          \n          echo \"VERSION file: $file_version\"\n          echo \"pt script:    $script_version\"\n          \n          if [[ \"$file_version\" \\!= \"$script_version\" ]]; then\n            echo \"\"\n            echo \"::error::Version mismatch\\!\"\n            echo \"VERSION file contains: $file_version\"\n            echo \"pt script contains:    $script_version\"\n            echo \"\"\n            echo \"Please update both to match.\"\n            exit 1\n          fi\n          \n          echo \"✓ Versions match: $file_version\"\n      \n      - name: Validate version format\n        run: |\n          version=$(cat VERSION | tr -d '\\n')\n          \n          # Check semver format (X.Y.Z)\n          if [[ \\! \"$version\" =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n            echo \"::error::Invalid version format: $version\"\n            echo \"Expected: X.Y.Z (e.g., 1.2.3)\"\n            exit 1\n          fi\n          \n          echo \"✓ Version format valid: $version\"\n```\n\n## Error Output\nGitHub Actions `::error::` syntax creates annotations visible in PR UI:\n- Red error badge\n- Clickable link to the check\n- Clear message about what's wrong\n\n## Success Criteria\n- [ ] Job checks VERSION file exists\n- [ ] Job compares VERSION file to script constant\n- [ ] Job validates semver format\n- [ ] Clear error messages on mismatch\n- [ ] PR blocked if versions don't match","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:37:32.920319677-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:37:32.920319677-05:00","dependencies":[{"issue_id":"process_triage-dna","depends_on_id":"process_triage-nk1","type":"blocks","created_at":"2026-01-14T22:40:46.352321011-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-e4y","title":"Add console styling system tests","description":"## Purpose\nCreate tests to verify the console styling system works correctly across different terminal environments.\n\n## Parent Epic\nConsole Output Styling Enhancement (process_triage-y8e)\n\n## Depends On\n- Add TTY detection and NO_COLOR support (process_triage-18z)\n- Implement log_* functions with emoji prefixes (process_triage-vpb)\n- Add ANSI fallback when gum unavailable (process_triage-ch7)\n\n## Why This Is Important\nThe styling system has multiple code paths:\n1. TTY with gum → full styling\n2. TTY without gum → ANSI fallback\n3. Non-TTY (pipe) → no styling\n4. NO_COLOR set → no colors\n5. CI environment → minimal styling\n\nEach path must be tested to ensure correct behavior.\n\n## Test Scenarios\n\n### test/test_console_styling.bats\n\n```bash\n#!/usr/bin/env bats\n\nload 'test_helper/common'\n\nsetup() {\n    setup_test_env\n    test_start \"$BATS_TEST_NAME\" \"Console styling test\"\n    export PT_SCRIPT=\"${BATS_TEST_DIRNAME}/../pt\"\n}\n\nteardown() {\n    test_end \"$BATS_TEST_NAME\" \"${BATS_TEST_COMPLETED:-fail}\"\n    restore_path\n    teardown_test_env\n}\n\n#==============================================================================\n# TTY DETECTION TESTS\n#==============================================================================\n\n@test \"Styling: detects TTY correctly\" {\n    test_info \"Testing TTY detection\"\n    \n    # When run directly (not piped), should detect TTY\n    # This is tricky to test because BATS output is piped\n    \n    # Test the detection logic directly by sourcing\n    source \"$PT_SCRIPT\" 2\u003e/dev/null || true\n    \n    test_info \"IS_TTY should be set based on terminal\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: piped output disables colors\" {\n    test_info \"Testing piped output detection\"\n    \n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    # Pipe through cat to simulate non-TTY\n    output=$(\"$PT_SCRIPT\" scan 2\u003e\u00261 | cat)\n    \n    test_info \"Checking for absence of escape codes in piped output\"\n    \n    # Should NOT contain ANSI escape codes when piped\n    # Note: escape code is \\033 or \\e\n    if [[ \"$output\" == *$'\\033'* ]]; then\n        test_warn \"Found escape codes in piped output\"\n        # This might be acceptable if stderr is still TTY\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# NO_COLOR SUPPORT TESTS\n#==============================================================================\n\n@test \"Styling: NO_COLOR=1 disables all colors\" {\n    test_info \"Testing NO_COLOR support\"\n    \n    export NO_COLOR=1\n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    test_info \"Running pt scan with NO_COLOR=1\"\n    run \"$PT_SCRIPT\" scan\n    \n    test_info \"Output: $output\"\n    \n    # Should NOT contain ANSI escape sequences\n    assert_not_contains \"$output\" $'\\033[' \"Should not contain ANSI codes\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: NO_COLOR=0 still disables colors (presence matters, not value)\" {\n    test_info \"Testing NO_COLOR=0 (any value disables)\"\n    \n    # Per no-color.org spec, presence of variable matters, not value\n    export NO_COLOR=0\n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    run \"$PT_SCRIPT\" scan\n    \n    # Should still be disabled (NO_COLOR is set)\n    # This depends on implementation following the spec\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: unset NO_COLOR allows colors\" {\n    test_info \"Testing without NO_COLOR\"\n    \n    unset NO_COLOR\n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    # This test is tricky because BATS captures output\n    # Colors would appear in TTY but not in captured output\n    \n    test_info \"Running without NO_COLOR\"\n    run \"$PT_SCRIPT\" scan\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# CI ENVIRONMENT TESTS\n#==============================================================================\n\n@test \"Styling: CI=true modifies behavior\" {\n    test_info \"Testing CI environment detection\"\n    \n    export CI=true\n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    test_info \"Running pt scan with CI=true\"\n    run \"$PT_SCRIPT\" scan\n    \n    # In CI, should work without interactive elements\n    assert_equals \"0\" \"$status\" \"Should succeed in CI\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: GITHUB_ACTIONS=true detected as CI\" {\n    test_info \"Testing GitHub Actions detection\"\n    \n    export GITHUB_ACTIONS=true\n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    use_mock_bin\n    \n    run \"$PT_SCRIPT\" scan\n    \n    assert_equals \"0\" \"$status\" \"Should succeed in GitHub Actions\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# GUM AVAILABILITY TESTS\n#==============================================================================\n\n@test \"Styling: works without gum installed\" {\n    test_info \"Testing fallback when gum unavailable\"\n    \n    # Hide gum from PATH\n    mkdir -p \"${MOCK_BIN}\"\n    cat \u003e \"${MOCK_BIN}/gum\" \u003c\u003c 'EOF'\n#!/bin/bash\nexit 127  # Command not found\nEOF\n    chmod +x \"${MOCK_BIN}/gum\"\n    \n    # Also remove real gum from PATH\n    export PATH=\"${MOCK_BIN}:/usr/bin:/bin\"\n    \n    create_mock_ps \"$(mock_ps_with_stuck_test)\"\n    \n    test_info \"Running pt scan without gum\"\n    run \"$PT_SCRIPT\" scan\n    \n    # Should still work using ANSI fallback\n    # Might show warning about gum\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: gum_confirm falls back to read\" {\n    test_info \"Testing gum_confirm fallback\"\n    \n    # This tests the wrapper function directly\n    # Hide gum\n    export PATH=\"/usr/bin:/bin\"\n    export GUM_AVAILABLE=false\n    \n    # The fallback should use read for input\n    # This is hard to test automatically\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# LOG FUNCTION TESTS\n#==============================================================================\n\n@test \"Styling: log_info outputs to stderr\" {\n    test_info \"Testing log_info output stream\"\n    \n    # Source the script to get functions\n    source \"$PT_SCRIPT\" 2\u003e/dev/null || true\n    \n    # If log_info is available, test it\n    if declare -f log_info \u003e/dev/null 2\u003e\u00261; then\n        # Capture stderr separately\n        local stderr_output\n        stderr_output=$(log_info \"test message\" 2\u003e\u00261 \u003e/dev/null)\n        \n        test_info \"stderr output: $stderr_output\"\n        assert_contains \"$stderr_output\" \"test message\" \"Should output to stderr\"\n    else\n        test_warn \"log_info not yet implemented\"\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: log_error includes error indicator\" {\n    test_info \"Testing log_error formatting\"\n    \n    source \"$PT_SCRIPT\" 2\u003e/dev/null || true\n    \n    if declare -f log_error \u003e/dev/null 2\u003e\u00261; then\n        local output\n        output=$(log_error \"test error\" 2\u003e\u00261)\n        \n        # Should include error indicator (✗ or [ERROR] etc)\n        test_info \"Error output: $output\"\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: log_success includes success indicator\" {\n    test_info \"Testing log_success formatting\"\n    \n    source \"$PT_SCRIPT\" 2\u003e/dev/null || true\n    \n    if declare -f log_success \u003e/dev/null 2\u003e\u00261; then\n        local output\n        output=$(log_success \"test success\" 2\u003e\u00261)\n        \n        # Should include success indicator (✓ or [OK] etc)\n        test_info \"Success output: $output\"\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# COLOR CODE TESTS\n#==============================================================================\n\n@test \"Styling: color variables defined when USE_COLOR=true\" {\n    test_info \"Testing color variable definitions\"\n    \n    unset NO_COLOR\n    export USE_COLOR=true\n    \n    source \"$PT_SCRIPT\" 2\u003e/dev/null || true\n    \n    # Check color variables are set\n    if [[ -n \"${RED:-}\" ]]; then\n        test_info \"RED is defined: ${RED@Q}\"\n        # Should contain escape code\n        [[ \"$RED\" == *\"033\"* ]] || [[ \"$RED\" == *\"e[\"* ]]\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"Styling: color variables empty when USE_COLOR=false\" {\n    test_info \"Testing color variables disabled\"\n    \n    export NO_COLOR=1\n    \n    source \"$PT_SCRIPT\" 2\u003e/dev/null || true\n    \n    # Color variables should be empty\n    if [[ -z \"${RED:-}\" ]] || [[ \"$RED\" == \"\" ]]; then\n        test_info \"RED is correctly empty when colors disabled\"\n    fi\n    \n    BATS_TEST_COMPLETED=pass\n}\n```\n\n## Success Criteria\n- [ ] TTY detection tested\n- [ ] Piped output tested\n- [ ] NO_COLOR support tested (various values)\n- [ ] CI environment detection tested\n- [ ] Gum availability/fallback tested\n- [ ] Log functions tested (stderr, formatting)\n- [ ] Color variable states tested\n- [ ] All tests have detailed logging","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:49:14.0288411-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:49:14.0288411-05:00","dependencies":[{"issue_id":"process_triage-e4y","depends_on_id":"process_triage-ch7","type":"blocks","created_at":"2026-01-14T22:50:31.747722531-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-h2y","title":"Add test helper with mock injection","description":"## Purpose\nCreate a test helper file with shared setup, teardown, mock injection utilities, and **comprehensive logging** for debugging test failures.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## CRITICAL: Test Logging Requirements\nAll test utilities must provide detailed logging:\n- Every test should output what it's testing and expected outcome\n- All mock setups should log what they're mocking\n- Failures should include full context (expected vs actual, relevant state)\n- Use TAP-compatible output for CI integration\n\n## Implementation\n\n### test/test_helper/common.bash\n```bash\n#!/usr/bin/env bash\n# Test helper functions for pt BATS tests\n# Provides: setup/teardown, mocks, assertions, logging\n\n#==============================================================================\n# TEST LOGGING\n#==============================================================================\n# All test output should be detailed and debuggable\n\nTEST_LOG_LEVEL=${TEST_LOG_LEVEL:-info}  # debug, info, warn, error\n\ntest_log() {\n    local level=\"$1\"\n    shift\n    local msg=\"$*\"\n    local timestamp=\"$(date '+%H:%M:%S.%3N')\"\n    \n    case \"$level\" in\n        debug) [[ \"$TEST_LOG_LEVEL\" == \"debug\" ]] \u0026\u0026 echo \"# [$timestamp] DEBUG: $msg\" ;;\n        info)  echo \"# [$timestamp] INFO:  $msg\" ;;\n        warn)  echo \"# [$timestamp] WARN:  $msg\" \u003e\u00262 ;;\n        error) echo \"# [$timestamp] ERROR: $msg\" \u003e\u00262 ;;\n    esac\n}\n\ntest_debug() { test_log debug \"$@\"; }\ntest_info()  { test_log info \"$@\"; }\ntest_warn()  { test_log warn \"$@\"; }\ntest_error() { test_log error \"$@\"; }\n\n# Log test start with description\ntest_start() {\n    local test_name=\"$1\"\n    local description=\"$2\"\n    test_info \"=== START: $test_name ===\"\n    test_info \"Testing: $description\"\n}\n\n# Log test completion with result\ntest_end() {\n    local test_name=\"$1\"\n    local status=\"$2\"\n    if [[ \"$status\" == \"pass\" ]]; then\n        test_info \"=== PASS: $test_name ===\"\n    else\n        test_error \"=== FAIL: $test_name ===\"\n    fi\n}\n\n#==============================================================================\n# TEST ENVIRONMENT SETUP\n#==============================================================================\n\nsetup_test_env() {\n    test_debug \"Setting up test environment...\"\n    \n    # Create isolated directories\n    export TEST_DIR=\"${BATS_TEST_TMPDIR}/test_env\"\n    export CONFIG_DIR=\"${TEST_DIR}/config\"\n    export MOCK_BIN=\"${TEST_DIR}/mock_bin\"\n    export TEST_LOG_FILE=\"${TEST_DIR}/test.log\"\n    \n    mkdir -p \"$CONFIG_DIR\" \"$MOCK_BIN\"\n    \n    # Initialize empty decisions file\n    echo '{}' \u003e \"${CONFIG_DIR}/decisions.json\"\n    \n    # Set test mode flags\n    export TEST_MODE=1\n    export CI=true\n    export NO_COLOR=1\n    \n    test_debug \"TEST_DIR=$TEST_DIR\"\n    test_debug \"CONFIG_DIR=$CONFIG_DIR\"\n    test_debug \"MOCK_BIN=$MOCK_BIN\"\n    \n    test_info \"Test environment ready\"\n}\n\nteardown_test_env() {\n    test_debug \"Tearing down test environment...\"\n    \n    # Log any test artifacts before cleanup\n    if [[ -f \"$TEST_LOG_FILE\" ]]; then\n        test_debug \"Test log contents:\"\n        cat \"$TEST_LOG_FILE\" | while read line; do\n            test_debug \"  $line\"\n        done\n    fi\n    \n    rm -rf \"${BATS_TEST_TMPDIR}/test_env\"\n    test_debug \"Cleanup complete\"\n}\n\n#==============================================================================\n# MOCK CREATION UTILITIES\n#==============================================================================\n\n# Create a mock command that outputs predefined text\n# Usage: create_mock_command name output [exit_code]\ncreate_mock_command() {\n    local name=\"$1\"\n    local output=\"$2\"\n    local exit_code=\"${3:-0}\"\n    \n    test_debug \"Creating mock command: $name (exit=$exit_code)\"\n    test_debug \"Mock output: ${output:0:100}...\"\n    \n    cat \u003e \"${MOCK_BIN}/${name}\" \u003c\u003c EOF\n#!/usr/bin/env bash\ncat \u003c\u003c 'MOCK_OUTPUT'\n${output}\nMOCK_OUTPUT\nexit ${exit_code}\nEOF\n    chmod +x \"${MOCK_BIN}/${name}\"\n    \n    test_info \"Mock '$name' created at ${MOCK_BIN}/${name}\"\n}\n\n# Create mock ps command with specific process output\ncreate_mock_ps() {\n    local processes=\"$1\"\n    test_info \"Creating mock ps with $(echo \"$processes\" | wc -l) processes\"\n    create_mock_command \"ps\" \"$processes\"\n}\n\n# Create mock curl that returns specific content\ncreate_mock_curl() {\n    local content=\"$1\"\n    local exit_code=\"${2:-0}\"\n    test_info \"Creating mock curl (exit=$exit_code, content_len=${#content})\"\n    create_mock_command \"curl\" \"$content\" \"$exit_code\"\n}\n\n# Create mock curl that simulates redirect for version checking\ncreate_mock_curl_redirect() {\n    local final_url=\"$1\"\n    test_info \"Creating mock curl redirect to: $final_url\"\n    \n    cat \u003e \"${MOCK_BIN}/curl\" \u003c\u003c EOF\n#!/usr/bin/env bash\n# Mock curl that handles -w '%{url_effective}'\nif [[ \"$*\" == *\"url_effective\"* ]]; then\n    echo \"$final_url\"\nelse\n    # Default behavior\n    cat /dev/null\nfi\nexit 0\nEOF\n    chmod +x \"${MOCK_BIN}/curl\"\n}\n\n#==============================================================================\n# MOCK PROCESS DATA GENERATORS\n#==============================================================================\n\n# Generate a mock process line in pt's expected format\n# Usage: mock_process PID PPID AGE_SECS MEM_MB \"command\"\nmock_process() {\n    local pid=\"$1\"\n    local ppid=\"$2\"\n    local age=\"$3\"\n    local mem=\"$4\"\n    local cmd=\"$5\"\n    \n    test_debug \"mock_process: pid=$pid ppid=$ppid age=$age mem=$mem cmd='$cmd'\"\n    printf '%s|%s|%s|%s|%s\\n' \"$pid\" \"$ppid\" \"$age\" \"$mem\" \"$cmd\"\n}\n\n# Pre-built scenarios\nmock_ps_with_stuck_test() {\n    local age=\"${1:-7200}\"  # 2 hours default\n    test_info \"Generating stuck test scenario (age=$age)\"\n    mock_process 12345 1000 \"$age\" 512 \"bun test --watch\"\n}\n\nmock_ps_with_orphan() {\n    test_info \"Generating orphan process scenario\"\n    mock_process 23456 1 86400 256 \"orphaned process\"\n}\n\nmock_ps_with_dev_server() {\n    local age=\"${1:-259200}\"  # 3 days default\n    test_info \"Generating old dev server scenario (age=$age)\"\n    mock_process 34567 1000 \"$age\" 128 \"next dev --port 3000\"\n}\n\nmock_ps_with_protected() {\n    test_info \"Generating protected process scenario\"\n    mock_process 1 0 9999999 100 \"/usr/lib/systemd/systemd\"\n}\n\nmock_ps_with_agent_shell() {\n    local age=\"${1:-90000}\"  # ~25 hours default\n    test_info \"Generating agent shell scenario (age=$age)\"\n    mock_process 45678 1000 \"$age\" 200 \"/bin/bash -c claude assistant\"\n}\n\n# Complex scenario with multiple process types\nmock_ps_mixed_scenario() {\n    test_info \"Generating mixed scenario with multiple process types\"\n    {\n        mock_process 10001 1000 3601 512 \"bun test --watch\"           # Stuck test\n        mock_process 10002 1 172800 256 \"orphaned background task\"    # Orphan + old\n        mock_process 10003 1000 259200 128 \"next dev --port 3000\"     # Old dev server\n        mock_process 10004 1000 90000 200 \"/bin/bash -c claude\"       # Agent shell\n        mock_process 10005 1000 1800 64 \"vim file.txt\"                # Normal (recent)\n        mock_process 1 0 9999999 100 \"/usr/lib/systemd/systemd\"       # Protected\n    }\n}\n\n#==============================================================================\n# ASSERTION HELPERS\n#==============================================================================\n\n# Assert score is within expected range\nassert_score_range() {\n    local actual=\"$1\"\n    local min=\"$2\"\n    local max=\"$3\"\n    local context=\"${4:-}\"\n    \n    test_debug \"assert_score_range: actual=$actual expected=[$min-$max] context='$context'\"\n    \n    if (( actual \u003c min || actual \u003e max )); then\n        test_error \"Score out of range\"\n        test_error \"  Expected: $min to $max\"\n        test_error \"  Actual:   $actual\"\n        [[ -n \"$context\" ]] \u0026\u0026 test_error \"  Context:  $context\"\n        return 1\n    fi\n    \n    test_debug \"Score $actual is within range [$min-$max] ✓\"\n    return 0\n}\n\n# Assert string contains substring\nassert_contains() {\n    local haystack=\"$1\"\n    local needle=\"$2\"\n    local context=\"${3:-}\"\n    \n    test_debug \"assert_contains: looking for '$needle' in '${haystack:0:50}...'\"\n    \n    if [[ \"$haystack\" != *\"$needle\"* ]]; then\n        test_error \"String does not contain expected substring\"\n        test_error \"  Looking for: '$needle'\"\n        test_error \"  In string:   '${haystack:0:200}'\"\n        [[ -n \"$context\" ]] \u0026\u0026 test_error \"  Context:     $context\"\n        return 1\n    fi\n    \n    test_debug \"Found '$needle' in string ✓\"\n    return 0\n}\n\n# Assert string does not contain substring\nassert_not_contains() {\n    local haystack=\"$1\"\n    local needle=\"$2\"\n    local context=\"${3:-}\"\n    \n    test_debug \"assert_not_contains: checking '$needle' absent from '${haystack:0:50}...'\"\n    \n    if [[ \"$haystack\" == *\"$needle\"* ]]; then\n        test_error \"String contains unexpected substring\"\n        test_error \"  Should not contain: '$needle'\"\n        test_error \"  But found in:       '${haystack:0:200}'\"\n        [[ -n \"$context\" ]] \u0026\u0026 test_error \"  Context:            $context\"\n        return 1\n    fi\n    \n    test_debug \"Confirmed '$needle' absent ✓\"\n    return 0\n}\n\n# Assert equality with detailed diff\nassert_equals() {\n    local expected=\"$1\"\n    local actual=\"$2\"\n    local context=\"${3:-}\"\n    \n    test_debug \"assert_equals: comparing values\"\n    \n    if [[ \"$expected\" != \"$actual\" ]]; then\n        test_error \"Values not equal\"\n        test_error \"  Expected: '$expected'\"\n        test_error \"  Actual:   '$actual'\"\n        [[ -n \"$context\" ]] \u0026\u0026 test_error \"  Context:  $context\"\n        return 1\n    fi\n    \n    test_debug \"Values match: '$expected' ✓\"\n    return 0\n}\n\n# Assert command succeeds\nassert_success() {\n    local cmd=\"$1\"\n    local context=\"${2:-}\"\n    \n    test_debug \"assert_success: running '$cmd'\"\n    \n    local output exit_code\n    output=\"$(eval \"$cmd\" 2\u003e\u00261)\"\n    exit_code=$?\n    \n    if [[ $exit_code -ne 0 ]]; then\n        test_error \"Command failed (expected success)\"\n        test_error \"  Command:   $cmd\"\n        test_error \"  Exit code: $exit_code\"\n        test_error \"  Output:    $output\"\n        [[ -n \"$context\" ]] \u0026\u0026 test_error \"  Context:   $context\"\n        return 1\n    fi\n    \n    test_debug \"Command succeeded (exit=0) ✓\"\n    echo \"$output\"\n    return 0\n}\n\n# Assert command fails\nassert_fails() {\n    local cmd=\"$1\"\n    local expected_exit=\"${2:-}\"\n    local context=\"${3:-}\"\n    \n    test_debug \"assert_fails: running '$cmd'\"\n    \n    local output exit_code\n    output=\"$(eval \"$cmd\" 2\u003e\u00261)\"\n    exit_code=$?\n    \n    if [[ $exit_code -eq 0 ]]; then\n        test_error \"Command succeeded (expected failure)\"\n        test_error \"  Command: $cmd\"\n        test_error \"  Output:  $output\"\n        [[ -n \"$context\" ]] \u0026\u0026 test_error \"  Context: $context\"\n        return 1\n    fi\n    \n    if [[ -n \"$expected_exit\" ]] \u0026\u0026 [[ $exit_code -ne $expected_exit ]]; then\n        test_error \"Wrong exit code\"\n        test_error \"  Expected: $expected_exit\"\n        test_error \"  Actual:   $exit_code\"\n        return 1\n    fi\n    \n    test_debug \"Command failed as expected (exit=$exit_code) ✓\"\n    echo \"$output\"\n    return 0\n}\n\n#==============================================================================\n# SKIP HELPERS\n#==============================================================================\n\nskip_if_no_jq() {\n    if ! command -v jq \u0026\u003e/dev/null; then\n        test_warn \"Skipping: jq not installed\"\n        skip \"jq not installed\"\n    fi\n}\n\nskip_if_no_gum() {\n    if ! command -v gum \u0026\u003e/dev/null; then\n        test_warn \"Skipping: gum not installed\"\n        skip \"gum not installed\"\n    fi\n}\n\nskip_if_ci() {\n    if [[ -n \"${CI:-}\" ]]; then\n        test_warn \"Skipping: CI environment\"\n        skip \"Skipped in CI environment\"\n    fi\n}\n\nskip_if_root() {\n    if [[ $EUID -eq 0 ]]; then\n        test_warn \"Skipping: running as root\"\n        skip \"Skipped when running as root\"\n    fi\n}\n\n#==============================================================================\n# PATH MANIPULATION FOR MOCKS\n#==============================================================================\n\nuse_mock_bin() {\n    test_info \"Injecting mock bin into PATH\"\n    test_debug \"MOCK_BIN=$MOCK_BIN\"\n    export ORIGINAL_PATH=\"$PATH\"\n    export PATH=\"${MOCK_BIN}:${PATH}\"\n    test_debug \"New PATH: $PATH\"\n}\n\nrestore_path() {\n    if [[ -n \"${ORIGINAL_PATH:-}\" ]]; then\n        test_debug \"Restoring original PATH\"\n        export PATH=\"$ORIGINAL_PATH\"\n        unset ORIGINAL_PATH\n    fi\n}\n\n#==============================================================================\n# FILE COMPARISON UTILITIES\n#==============================================================================\n\n# Create a snapshot of a file for comparison\nsnapshot_file() {\n    local file=\"$1\"\n    local snapshot_name=\"$2\"\n    \n    if [[ -f \"$file\" ]]; then\n        cp \"$file\" \"${TEST_DIR}/${snapshot_name}.snapshot\"\n        test_debug \"Created snapshot: $snapshot_name\"\n    else\n        test_warn \"Cannot snapshot: $file does not exist\"\n    fi\n}\n\n# Compare file with snapshot\ncompare_with_snapshot() {\n    local file=\"$1\"\n    local snapshot_name=\"$2\"\n    local snapshot=\"${TEST_DIR}/${snapshot_name}.snapshot\"\n    \n    if [[ ! -f \"$snapshot\" ]]; then\n        test_error \"Snapshot not found: $snapshot_name\"\n        return 1\n    fi\n    \n    if diff -q \"$file\" \"$snapshot\" \u003e/dev/null 2\u003e\u00261; then\n        test_debug \"File matches snapshot: $snapshot_name ✓\"\n        return 0\n    else\n        test_error \"File differs from snapshot: $snapshot_name\"\n        test_error \"Diff:\"\n        diff \"$snapshot\" \"$file\" | while read line; do\n            test_error \"  $line\"\n        done\n        return 1\n    fi\n}\n\n#==============================================================================\n# TIMING UTILITIES\n#==============================================================================\n\n# Time a command and report duration\ntime_command() {\n    local description=\"$1\"\n    shift\n    local cmd=\"$*\"\n    \n    local start end duration\n    start=$(date +%s%3N)\n    eval \"$cmd\"\n    local exit_code=$?\n    end=$(date +%s%3N)\n    duration=$((end - start))\n    \n    test_info \"$description completed in ${duration}ms (exit=$exit_code)\"\n    return $exit_code\n}\n```\n\n## Success Criteria\n- [ ] Test logging provides TAP-compatible output\n- [ ] All test utilities log their actions\n- [ ] Mock creation is logged with details\n- [ ] Assertion failures include full context\n- [ ] Setup/teardown logging aids debugging\n- [ ] PATH manipulation is logged and reversible\n- [ ] Timing utilities available for performance tests","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:39:24.535919856-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:45:56.061384895-05:00"}
{"id":"process_triage-i5r","title":"Create ci.yml with ShellCheck job","description":"## Purpose\nCreate the CI workflow file with ShellCheck static analysis as the first quality gate.\n\n## Parent Epic\nGitHub Actions CI/CD Pipeline (process_triage-68c)\n\n## Why ShellCheck First?\nShellCheck catches common bash issues:\n- Unquoted variables (`$var` vs `\"$var\"`)\n- Deprecated syntax\n- Portability issues\n- Common mistakes (SC2086, SC2046, etc.)\n\nRunning it first provides fast feedback before running longer tests.\n\n## Implementation\n\n### .github/workflows/ci.yml\n```yaml\nname: CI\n\non:\n  push:\n    branches: [main, master]\n  pull_request:\n    branches: [main, master]\n  workflow_dispatch:  # Allow manual trigger\n\njobs:\n  shellcheck:\n    name: ShellCheck\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Run ShellCheck\n        uses: ludeeus/action-shellcheck@master\n        with:\n          severity: warning\n          scandir: '.'\n          additional_files: 'pt install.sh'\n        env:\n          SHELLCHECK_OPTS: '-e SC2155 -e SC2034'\n```\n\n## ShellCheck Exclusions\n\n### SC2155: Declare and assign separately\n```bash\n# SC2155 warns about this:\nlocal foo=\"$(command)\"\n\n# Wants this instead:\nlocal foo\nfoo=\"$(command)\"\n```\nWe exclude this because the combined form is more readable and the risk is minimal.\n\n### SC2034: Variable appears unused\nThis fires on variables used in heredocs or sourced files. Exclude to reduce noise.\n\n## Severity Levels\n- **error**: Script will likely fail\n- **warning**: Potential issues (our threshold)\n- **info**: Style suggestions\n- **style**: Purely cosmetic\n\nSetting `severity: warning` catches real issues without being overly pedantic.\n\n## Success Criteria\n- [ ] ci.yml created in .github/workflows/\n- [ ] ShellCheck job runs on push/PR\n- [ ] Appropriate exclusions configured\n- [ ] Passes on current codebase (or issues fixed)","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:37:30.873339841-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:37:30.873339841-05:00"}
{"id":"process_triage-n0r","title":"Installation Infrastructure","description":"## Overview\nCreate a professional installation script (install.sh) that matches the quality of repo_updater and giil installers.\n\n## Current State\n- README suggests manual: `git clone` + `ln -s`\n- No one-liner installation\n- No checksum verification option\n- No PATH management\n- No upgrade detection\n\n## Target State\nA polished installer supporting:\n```bash\n# One-liner install (like giil/repo_updater)\ncurl -fsSL https://raw.githubusercontent.com/USER/process_triage/main/install.sh | bash\n\n# With verification\nVERIFY=1 curl -fsSL .../install.sh | bash\n\n# Custom location\nDEST=/custom/path curl -fsSL .../install.sh | bash\n\n# System-wide\nPT_SYSTEM=1 curl -fsSL .../install.sh | bash\n```\n\n## Key Features (from repo_updater/giil)\n\n### 1. Self-Refresh Mechanism\nWhen piped from curl, the installer re-fetches itself to avoid CDN stale cache issues:\n```bash\nmaybe_self_refresh_installer() {\n    if [[ -p /dev/stdin ]]; then\n        # Being piped - re-download fresh copy\n        exec bash \u003c(curl -fsSL \"$INSTALLER_URL?cb=$(date +%s)\")\n    fi\n}\n```\n\n### 2. Cache-Busting\nAppend timestamp to URLs to bypass CDN caching:\n```bash\nappend_cache_buster() {\n    local url=\"$1\"\n    echo \"${url}?cb=$(date +%s)\"\n}\n```\n\n### 3. Cross-Platform mktemp\n```bash\nmktemp_dir() {\n    mktemp -d 2\u003e/dev/null ||           # GNU (Linux)\n    mktemp -d -t pt 2\u003e/dev/null ||     # BSD (macOS)\n    mktemp -d -t pt.XXXXXXXXXX         # BSD fallback\n}\n```\n\n### 4. Multi-Package-Manager gum Installation\nSupport: apt, dnf, pacman, brew, direct binary download\n\n### 5. Optional Checksum Verification\n```bash\nif [[ \"${VERIFY:-}\" == \"1\" ]]; then\n    verify_checksum \"$downloaded_file\" \"$version\"\nfi\n```\n\n### 6. PATH Management\n- Auto-detect shell (bash, zsh, fish)\n- Add to appropriate config file\n- Skip if already in PATH\n- Disable with PT_NO_PATH=1\n\n### 7. Upgrade Detection\n- Show current → new version\n- Handle re-install of same version gracefully\n\n## Environment Variables\n| Variable | Purpose |\n|----------|---------|\n| DEST | Custom install directory |\n| PT_SYSTEM | Install to /usr/local/bin |\n| PT_NO_PATH | Skip PATH modification |\n| VERIFY | Enable checksum verification |\n| PT_VERSION | Install specific version |\n\n## Success Criteria\n- [ ] One-liner install works on Linux and macOS\n- [ ] Checksum verification works when enabled\n- [ ] PATH is correctly managed for bash/zsh/fish\n- [ ] Upgrade detection shows version changes\n- [ ] Clear success/failure messaging\n- [ ] Handles curl and wget as download tools","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:32:41.602455595-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:32:41.602455595-05:00"}
{"id":"process_triage-nk1","title":"Create VERSION file as single source of truth","description":"## Purpose\nCreate a VERSION file that serves as the single source of truth for the project version, matching the pattern used in repo_updater and giil.\n\n## Why a Separate VERSION File?\n1. **CI/CD Access**: GitHub Actions can read it without parsing bash\n2. **Installer Access**: install.sh can fetch it independently\n3. **Self-Update**: Update checker compares against this file\n4. **Consistency Checks**: CI validates VERSION file matches script constant\n\n## Implementation\n\n### 1. Create VERSION file\n```\n1.0.0\n```\n(Just the version number, no newline issues - use `echo -n` or ensure single line)\n\n### 2. Update pt script to read from VERSION or define constant\n```bash\n# Option A: Read from file (if present)\nif [[ -f \"${BASH_SOURCE[0]%/*}/VERSION\" ]]; then\n    VERSION=\"$(\u003c \"${BASH_SOURCE[0]%/*}/VERSION\")\"\nelse\n    VERSION=\"1.0.0\"  # Fallback for standalone execution\nfi\n\n# Option B: Keep constant in script (simpler, CI validates consistency)\nVERSION=\"1.0.0\"\n```\n\n### 3. Ensure VERSION constant exists in script\nThe script already has VERSION=\"1.0.0\" on line 5. This is correct.\nThe VERSION file should match this value.\n\n## File Location\n```\nprocess_triage/\n├── VERSION          # ← New file\n├── pt\n├── ...\n```\n\n## Validation (for CI)\n```bash\nfile_version=$(cat VERSION)\nscript_version=$(grep '^VERSION=' pt | cut -d'\"' -f2)\n[[ \"$file_version\" == \"$script_version\" ]] || {\n    echo \"VERSION mismatch: file=$file_version, script=$script_version\"\n    exit 1\n}\n```\n\n## Success Criteria\n- [ ] VERSION file exists with current version\n- [ ] Script VERSION constant matches file\n- [ ] No trailing newline issues\n- [ ] File is tracked in git\n\n## Parent Epic\nThis is a foundational task for: Self-Update Mechanism (process_triage-097)","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:33:31.38327042-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:33:31.38327042-05:00"}
{"id":"process_triage-omq","title":"Add bash syntax validation job to CI","description":"## Purpose\nAdd a CI job that validates bash syntax using `bash -n` to catch parse errors.\n\n## Parent Epic\nGitHub Actions CI/CD Pipeline (process_triage-68c)\n\n## Depends On\n- Create ci.yml with ShellCheck job (add to same file)\n\n## Why bash -n?\n- Catches syntax errors that would cause script to fail\n- Catches unterminated heredocs\n- Catches mismatched quotes/brackets\n- Fast (no execution, just parsing)\n\n## Implementation\n\n### Add to ci.yml\n```yaml\n  syntax:\n    name: Bash Syntax\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      \n      - name: Validate pt syntax\n        run: bash -n pt\n      \n      - name: Validate install.sh syntax\n        run: bash -n install.sh\n      \n      - name: Validate test files\n        run: |\n          for file in test/*.bats; do\n            echo \"Checking $file...\"\n            # BATS files aren't pure bash, but we can check helper functions\n            # Skip actual test cases which use BATS syntax\n            bash -n \"$file\" 2\u003e/dev/null || true\n          done\n```\n\n## Note on BATS Files\nBATS files use special syntax (`@test`, `load`) that isn't valid bash.\nThe syntax check for .bats files may show warnings - that's expected.\nWe primarily care about pt and install.sh.\n\n## Success Criteria\n- [ ] Syntax job added to ci.yml\n- [ ] pt passes bash -n\n- [ ] install.sh passes bash -n\n- [ ] Job fails if syntax error introduced","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:37:31.687777577-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:37:31.687777577-05:00","dependencies":[{"issue_id":"process_triage-omq","depends_on_id":"process_triage-i5r","type":"blocks","created_at":"2026-01-14T22:40:46.266216181-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-or6","title":"Implement atomic file replacement","description":"## Purpose\nReplace the running script atomically to prevent corruption if the update is interrupted.\n\n## Parent Epic\nSelf-Update Mechanism (process_triage-097)\n\n## Depends On\n- Add bash syntax validation before replacement\n\n## The Problem\nNon-atomic replacement:\n```bash\n# DANGEROUS: If interrupted mid-write, file is corrupted\ncat downloaded_file \u003e /path/to/pt\n```\n\nAtomic replacement:\n```bash\n# SAFE: Either old file or new file, never partial\nmv temp_file /path/to/pt\n```\n\n## Implementation\n\n### Atomic Replacement Function\n```bash\natomic_replace() {\n    local source=\"$1\"\n    local target=\"$2\"\n    \n    # Preserve permissions from original\n    local perms\n    if [[ -f \"$target\" ]]; then\n        perms=$(stat -c '%a' \"$target\" 2\u003e/dev/null || stat -f '%Lp' \"$target\" 2\u003e/dev/null)\n    else\n        perms=\"755\"\n    fi\n    \n    # Set permissions on new file\n    chmod \"$perms\" \"$source\"\n    \n    # Atomic move\n    # mv is atomic on POSIX filesystems when source and target are on same filesystem\n    if \\! mv \"$source\" \"$target\"; then\n        log_error \"Failed to replace $target\"\n        log_error \"The original file is unchanged.\"\n        return 1\n    fi\n    \n    log_success \"Replaced $target\"\n    return 0\n}\n```\n\n### Complete Update Flow\n```bash\ndo_update() {\n    local version=\"$1\"\n    local script_path\n    \n    # Get path to currently running script\n    script_path=\"$(readlink -f \"${BASH_SOURCE[0]}\" 2\u003e/dev/null || realpath \"${BASH_SOURCE[0]}\" 2\u003e/dev/null)\"\n    \n    # Check we can write to target directory\n    local target_dir=\"${script_path%/*}\"\n    if [[ \\! -w \"$target_dir\" ]]; then\n        log_error \"Cannot write to $target_dir\"\n        log_error \"Try running with sudo, or move pt to a writable location.\"\n        return 1\n    fi\n    \n    # Create temp file IN SAME DIRECTORY (required for atomic mv)\n    local temp_file\n    temp_file=\"$(mktemp \"${script_path}.update.XXXXXX\")\"\n    \n    # Cleanup on exit\n    trap \"rm -f '$temp_file' 2\u003e/dev/null\" EXIT\n    \n    # Download\n    log_step \"Downloading pt v${version}...\"\n    if \\! curl -fsSL \"${RELEASES_URL}/download/v${version}/pt\" -o \"$temp_file\"; then\n        log_error \"Download failed\"\n        return 1\n    fi\n    \n    # Verify checksum\n    if \\! verify_checksum \"$temp_file\" \"$version\"; then\n        return 1\n    fi\n    \n    # Validate script\n    if \\! validate_script \"$temp_file\"; then\n        return 1\n    fi\n    \n    # Atomic replacement\n    log_step \"Installing update...\"\n    if \\! atomic_replace \"$temp_file\" \"$script_path\"; then\n        return 1\n    fi\n    \n    log_success \"Updated to pt v${version}\"\n    log_info \"Run 'pt --version' to verify.\"\n    \n    # Clear trap (file was moved, not deleted)\n    trap - EXIT\n    \n    return 0\n}\n```\n\n### Why Same Directory for Temp File?\n`mv` is only atomic when source and target are on the same filesystem.\n- If temp file is in /tmp and target is in /usr/local/bin, mv does a copy+delete (not atomic)\n- Creating temp file in same directory guarantees same filesystem\n\n### Cross-Platform stat\n```bash\n# Linux (GNU coreutils)\nstat -c '%a' file\n\n# macOS/BSD\nstat -f '%Lp' file\n```\n\n## Success Criteria\n- [ ] Temp file created in same directory as target\n- [ ] Permissions preserved from original\n- [ ] mv used for atomic replacement\n- [ ] Failure leaves original file unchanged\n- [ ] Cleanup on error (temp file removed)\n- [ ] Write permission checked before download","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:35:07.503149012-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:35:07.503149012-05:00","dependencies":[{"issue_id":"process_triage-or6","depends_on_id":"process_triage-nk1","type":"blocks","created_at":"2026-01-14T22:52:20.721805635-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-ucg","title":"Add scoring system unit tests","description":"## Purpose\nAdd comprehensive tests for the process scoring heuristics system.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## Current State\nNo tests exist for the scoring system, which is the core logic of pt.\n\n## Implementation\n\n### test/test_scoring.bats\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Source the pt script to get access to functions\n    # We need to extract functions or source with modifications\n    export TEST_MODE=1\n    source \"${BATS_TEST_DIRNAME}/../pt\" 2\u003e/dev/null || true\n}\n\n#------------------------------------------------------------------------------\n# Age-based scoring tests\n#------------------------------------------------------------------------------\n\n@test \"score_process: age \u003e 1 week gets +50\" {\n    # 8 days in seconds = 691200\n    local result\n    result=$(score_process 1234 1000 691200 100 \"some process\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 50 ))\n}\n\n@test \"score_process: age \u003e 2 days gets +30\" {\n    # 3 days = 259200 seconds\n    local result\n    result=$(score_process 1234 1000 259200 100 \"some process\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 30 \u0026\u0026 score \u003c 50 ))\n}\n\n@test \"score_process: age \u003e 1 day gets +20\" {\n    # 1.5 days = 129600 seconds\n    local result\n    result=$(score_process 1234 1000 129600 100 \"some process\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 20 ))\n}\n\n@test \"score_process: age \u003c 1 day gets minimal score\" {\n    # 2 hours = 7200 seconds\n    local result\n    result=$(score_process 1234 1000 7200 100 \"some process\")\n    local score=${result%%|*}\n    \n    (( score \u003c 20 ))\n}\n\n#------------------------------------------------------------------------------\n# Orphan detection tests\n#------------------------------------------------------------------------------\n\n@test \"score_process: PPID=1 (orphan) gets +25\" {\n    # PPID=1 means parent died, process adopted by init\n    local result\n    result=$(score_process 1234 1 7200 100 \"orphaned process\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 25 ))\n}\n\n@test \"score_process: normal PPID doesn't get orphan bonus\" {\n    local result\n    result=$(score_process 1234 5678 7200 100 \"normal process\")\n    local score=${result%%|*}\n    \n    # Should be much lower without orphan bonus\n    (( score \u003c 25 ))\n}\n\n#------------------------------------------------------------------------------\n# Pattern matching tests\n#------------------------------------------------------------------------------\n\n@test \"score_process: stuck test runner (bun test) gets +40\" {\n    # Age \u003e 1 hour = 3601 seconds\n    local result\n    result=$(score_process 1234 1000 3601 100 \"bun test --watch\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 40 ))\n}\n\n@test \"score_process: stuck test runner (jest) gets +40\" {\n    local result\n    result=$(score_process 1234 1000 3601 100 \"node jest --runInBand\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 40 ))\n}\n\n@test \"score_process: stuck test runner (pytest) gets +40\" {\n    local result\n    result=$(score_process 1234 1000 3601 100 \"python -m pytest\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 40 ))\n}\n\n@test \"score_process: old dev server (next dev) gets +20\" {\n    # Age \u003e 2 days = 172801 seconds\n    local result\n    result=$(score_process 1234 1000 172801 100 \"next dev --port 3000\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 20 ))\n}\n\n@test \"score_process: agent shell (claude) gets +35\" {\n    # Age \u003e 1 day = 86401 seconds\n    local result\n    result=$(score_process 1234 1000 86401 100 \"/bin/bash -c claude something\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 35 ))\n}\n\n#------------------------------------------------------------------------------\n# Protection tests\n#------------------------------------------------------------------------------\n\n@test \"score_process: systemd service gets -200 (protected)\" {\n    local result\n    result=$(score_process 1234 1 691200 1000 \"/usr/lib/systemd/systemd\")\n    local score=${result%%|*}\n    \n    # Negative score = protected\n    (( score \u003c 0 ))\n}\n\n@test \"score_process: sshd is protected\" {\n    local result\n    result=$(score_process 1234 1 691200 1000 \"sshd: user@pts/0\")\n    local score=${result%%|*}\n    \n    (( score \u003c 0 ))\n}\n\n@test \"score_process: docker is protected\" {\n    local result\n    result=$(score_process 1234 1 691200 1000 \"dockerd --host=unix:///var/run/docker.sock\")\n    local score=${result%%|*}\n    \n    (( score \u003c 0 ))\n}\n\n#------------------------------------------------------------------------------\n# Memory hog tests\n#------------------------------------------------------------------------------\n\n@test \"score_process: high memory + old gets +15\" {\n    # \u003e 2000MB and \u003e 12 hours (43200 seconds)\n    local result\n    result=$(score_process 1234 1000 50000 2500 \"memory hog process\")\n    local score=${result%%|*}\n    \n    (( score \u003e= 15 ))\n}\n\n#------------------------------------------------------------------------------\n# Recommendation tests\n#------------------------------------------------------------------------------\n\n@test \"score_process: score \u003e= 50 recommends KILL\" {\n    local result\n    result=$(score_process 1234 1 691200 100 \"old orphaned process\")\n    local rec\n    IFS='|' read -r _ rec _ \u003c\u003c\u003c \"$result\"\n    \n    [[ \"$rec\" == \"KILL\" ]]\n}\n\n@test \"score_process: score 20-49 recommends REVIEW\" {\n    local result\n    result=$(score_process 1234 1000 129600 100 \"moderately old process\")\n    local rec\n    IFS='|' read -r _ rec _ \u003c\u003c\u003c \"$result\"\n    \n    [[ \"$rec\" == \"REVIEW\" ]]\n}\n\n@test \"score_process: score \u003c 20 recommends SPARE\" {\n    local result\n    result=$(score_process 1234 1000 3600 100 \"fresh process\")\n    local rec\n    IFS='|' read -r _ rec _ \u003c\u003c\u003c \"$result\"\n    \n    [[ \"$rec\" == \"SPARE\" ]]\n}\n```\n\n## Mocking Considerations\nThe score_process function may need to be refactored for testability:\n- Extract pure scoring logic that doesn't depend on external state\n- Or use TEST_MODE to skip decision memory lookup\n\n## Success Criteria\n- [ ] Age-based scoring tested at all thresholds\n- [ ] Orphan detection tested\n- [ ] All pattern matches tested (tests, dev servers, agents)\n- [ ] Protected patterns tested\n- [ ] Memory hog detection tested\n- [ ] Recommendation levels tested","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:39:22.235531431-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:39:22.235531431-05:00","dependencies":[{"issue_id":"process_triage-ucg","depends_on_id":"process_triage-h2y","type":"blocks","created_at":"2026-01-14T22:40:49.203228376-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-ume","title":"Create install.sh with self-refresh mechanism","description":"## Purpose\nCreate a professional installation script that can be piped from curl, with self-refresh to avoid CDN caching issues.\n\n## Parent Epic\nInstallation Infrastructure (process_triage-n0r)\n\n## Depends On\n- Create VERSION file as single source of truth\n\n## The Self-Refresh Pattern\nWhen piped from curl, the installer re-fetches itself to avoid stale CDN cache:\n\n```bash\n#\\!/usr/bin/env bash\nset -euo pipefail\n\nGITHUB_REPO=\"Dicklesworthstone/process_triage\"\nRAW_URL=\"https://raw.githubusercontent.com/${GITHUB_REPO}/main\"\n\n#------------------------------------------------------------------------------\n# Self-refresh: re-download fresh copy when piped\n#------------------------------------------------------------------------------\nmaybe_self_refresh() {\n    # Only refresh if being piped AND not already refreshed\n    if [[ -p /dev/stdin ]] \u0026\u0026 [[ -z \"${PT_REFRESHED:-}\" ]]; then\n        # Re-execute with cache-busted URL\n        export PT_REFRESHED=1\n        exec bash \u003c(curl -fsSL \"${RAW_URL}/install.sh?cb=$(date +%s)\")\n    fi\n}\n\nmaybe_self_refresh\n```\n\n## Why Self-Refresh?\nGitHub's CDN (raw.githubusercontent.com) caches files aggressively.\n- User runs `curl ... | bash` right after a release\n- Gets old cached version\n- Installs outdated script\n\nSelf-refresh ensures fresh download by:\n1. Detecting piped input (`-p /dev/stdin`)\n2. Re-downloading with cache-buster timestamp\n3. Exec-ing the fresh version\n\n## Core Implementation Structure\n\n```bash\n#\\!/usr/bin/env bash\nset -euo pipefail\n\nVERSION=\"1.0.0\"  # Installer version (not pt version)\nGITHUB_REPO=\"Dicklesworthstone/process_triage\"\nRAW_URL=\"https://raw.githubusercontent.com/${GITHUB_REPO}/main\"\nRELEASES_URL=\"https://github.com/${GITHUB_REPO}/releases\"\n\n#==============================================================================\n# SELF-REFRESH\n#==============================================================================\nmaybe_self_refresh() { ... }\nmaybe_self_refresh\n\n#==============================================================================\n# LOGGING\n#==============================================================================\nlog_info() { printf '\\033[0;34mℹ\\033[0m %s\\n' \"$*\" \u003e\u00262; }\nlog_success() { printf '\\033[0;32m✓\\033[0m %s\\n' \"$*\" \u003e\u00262; }\nlog_error() { printf '\\033[0;31m✗\\033[0m %s\\n' \"$*\" \u003e\u00262; }\nlog_step() { printf '\\033[0;36m→\\033[0m %s\\n' \"$*\" \u003e\u00262; }\n\n#==============================================================================\n# UTILITIES\n#==============================================================================\nmktemp_dir() {\n    mktemp -d 2\u003e/dev/null || mktemp -d -t pt 2\u003e/dev/null || mktemp -d -t pt.XXXXXXXXXX\n}\n\nget_latest_version() { ... }\n\n#==============================================================================\n# DOWNLOAD\n#==============================================================================\ndownload() { ... }\nverify_checksum() { ... }\n\n#==============================================================================\n# INSTALLATION\n#==============================================================================\ninstall_pt() { ... }\nadd_to_path() { ... }\n\n#==============================================================================\n# MAIN\n#==============================================================================\nmain() {\n    log_step \"Installing pt (Process Triage)...\"\n    \n    # Determine version to install\n    local version=\"${PT_VERSION:-}\"\n    if [[ -z \"$version\" ]]; then\n        version=$(get_latest_version)\n    fi\n    \n    # Determine install location\n    local dest=\"${DEST:-$HOME/.local/bin}\"\n    if [[ \"${PT_SYSTEM:-}\" == \"1\" ]]; then\n        dest=\"/usr/local/bin\"\n    fi\n    \n    # Download and install\n    local temp_dir\n    temp_dir=$(mktemp_dir)\n    trap \"rm -rf '$temp_dir'\" EXIT\n    \n    download \"$version\" \"$temp_dir/pt\"\n    \n    if [[ \"${VERIFY:-}\" == \"1\" ]]; then\n        verify_checksum \"$temp_dir/pt\" \"$version\"\n    fi\n    \n    install_pt \"$temp_dir/pt\" \"$dest\"\n    \n    # Add to PATH if needed\n    if [[ \"${PT_NO_PATH:-}\" \\!= \"1\" ]]; then\n        add_to_path \"$dest\"\n    fi\n    \n    log_success \"pt v${version} installed to $dest/pt\"\n    log_info \"Run 'pt help' to get started.\"\n}\n\nmain \"$@\"\n```\n\n## Success Criteria\n- [ ] Self-refresh mechanism works\n- [ ] One-liner install works: `curl ... | bash`\n- [ ] Version detection from releases\n- [ ] Custom install location via DEST\n- [ ] System-wide install via PT_SYSTEM=1\n- [ ] Cache-busting on URLs","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:36:30.398788198-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:36:30.398788198-05:00","dependencies":[{"issue_id":"process_triage-ume","depends_on_id":"process_triage-nk1","type":"blocks","created_at":"2026-01-14T22:40:45.368196458-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-vpb","title":"Implement log_* functions with emoji prefixes","description":"## Purpose\nCreate a consistent set of logging functions with emoji prefixes and color coding, matching the pattern from repo_updater and giil.\n\n## Parent Epic\nConsole Output Styling Enhancement (process_triage-y8e)\n\n## Depends On\n- Add TTY detection and NO_COLOR support (must have color variables defined)\n\n## Current State\npt has some output functions but they're inconsistent:\n- `log()` writes to log file only\n- Direct `printf` calls scattered throughout\n- No consistent prefix scheme\n\n## Implementation\n\n### Logging Function Set\n```bash\n#------------------------------------------------------------------------------\n# Logging functions (all output to stderr)\n#------------------------------------------------------------------------------\n\nlog_info() {\n    printf '%b\\n' \"${BLUE}ℹ${RESET} $*\" \u003e\u00262\n}\n\nlog_success() {\n    printf '%b\\n' \"${GREEN}✓${RESET} $*\" \u003e\u00262\n}\n\nlog_warn() {\n    printf '%b\\n' \"${YELLOW}⚠${RESET} $*\" \u003e\u00262\n}\n\nlog_error() {\n    printf '%b\\n' \"${RED}✗${RESET} $*\" \u003e\u00262\n}\n\nlog_step() {\n    printf '%b\\n' \"${CYAN}→${RESET} $*\" \u003e\u00262\n}\n\nlog_debug() {\n    [[ \"${PT_DEBUG:-}\" == \"1\" ]] || return 0\n    printf '%b\\n' \"${DIM}[DEBUG] $*${RESET}\" \u003e\u00262\n}\n\nlog_verbose() {\n    [[ \"${VERBOSE:-}\" == \"1\" ]] || return 0\n    printf '%b\\n' \"${DIM}$*${RESET}\" \u003e\u00262\n}\n```\n\n### Emoji Prefix Scheme\n| Function | Emoji | Color | Purpose |\n|----------|-------|-------|---------|\n| log_info | ℹ | Blue | Informational messages |\n| log_success | ✓ | Green | Success confirmations |\n| log_warn | ⚠ | Yellow | Warnings (non-fatal) |\n| log_error | ✗ | Red | Errors |\n| log_step | → | Cyan | Progress steps |\n| log_debug | [DEBUG] | Dim | Debug output (PT_DEBUG=1) |\n| log_verbose | (none) | Dim | Verbose output |\n\n### Why stderr?\nAll logging goes to stderr (`\u003e\u00262`) because:\n1. stdout is reserved for data output (JSON, process lists)\n2. Allows piping: `pt scan --json | jq '.'`\n3. Matches Unix convention\n\n### File Logging (keep existing)\n```bash\n# Existing log() function writes to file - keep it\nlog() {\n    printf '[%s] %s\\n' \"$(date '+%Y-%m-%d %H:%M:%S')\" \"$1\" \u003e\u003e \"$LOG_FILE\"\n}\n\n# Consider: Also call log() from log_info/log_error for audit trail\nlog_error() {\n    printf '%b\\n' \"${RED}✗${RESET} $*\" \u003e\u00262\n    log \"ERROR: $*\"  # Also write to file\n}\n```\n\n## Migration\nReplace existing output calls:\n```bash\n# Before\necho \"Found $count candidates\"\nprintf 'Error: %s\\n' \"$msg\"\n\n# After  \nlog_info \"Found $count candidates\"\nlog_error \"$msg\"\n```\n\n## Success Criteria\n- [ ] All log_* functions implemented\n- [ ] Consistent emoji prefix scheme\n- [ ] All output goes to stderr\n- [ ] Colors respect USE_COLOR variable\n- [ ] Debug output only shown when PT_DEBUG=1\n- [ ] Existing file logging preserved","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:33:31.728774252-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:33:31.728774252-05:00","dependencies":[{"issue_id":"process_triage-vpb","depends_on_id":"process_triage-18z","type":"blocks","created_at":"2026-01-14T22:40:43.702908755-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-y1z","title":"Define semantic exit codes","description":"## Purpose\nDefine meaningful exit codes for all error conditions, enabling scripting and automation.\n\n## Parent Epic\nCode Organization \u0026 Standards (process_triage-a6q)\n\n## Current State\npt uses generic exit codes (0 for success, 1 for error). No semantic meaning.\n\n## Exit Code Scheme\n\n```bash\n#==============================================================================\n# EXIT CODES\n#==============================================================================\n# Semantic exit codes for scripting and automation\n#\n# 0-9:   Success and user/usage states\n# 10-19: Dependency and environment errors\n# 20-29: Operation errors\n# 30-39: Update errors\n# 90+:   Internal errors\n\n# Success\nreadonly EXIT_SUCCESS=0\n\n# User/usage (1-9)\nreadonly EXIT_USAGE_ERROR=1       # Bad CLI arguments\nreadonly EXIT_NO_CANDIDATES=2     # No processes found (not an error, but distinct)\nreadonly EXIT_USER_CANCELLED=3    # User cancelled operation\n\n# Dependencies (10-19)\nreadonly EXIT_MISSING_GUM=10      # gum not available and couldn't install\nreadonly EXIT_MISSING_JQ=11       # jq not available (optional feature degraded)\nreadonly EXIT_MISSING_BASH=12     # Bash version too old\n\n# Operations (20-29)\nreadonly EXIT_KILL_FAILED=20      # Some processes couldn't be killed\nreadonly EXIT_KILL_PARTIAL=21     # Some killed, some failed\nreadonly EXIT_PERMISSION=22       # Permission denied\n\n# Updates (30-39)\nreadonly EXIT_UPDATE_NETWORK=30   # Network error during update check\nreadonly EXIT_UPDATE_CHECKSUM=31  # Checksum verification failed\nreadonly EXIT_UPDATE_SYNTAX=32    # Downloaded file not valid bash\nreadonly EXIT_UPDATE_WRITE=33     # Couldn't write updated script\n\n# Internal (90+)\nreadonly EXIT_INTERNAL=90         # Bug in pt (should never happen)\n```\n\n## Usage in Code\n\n```bash\n# Before (generic)\nlog_error \"Unknown command\"\nexit 1\n\n# After (semantic)\nlog_error \"Unknown command: $1\"\nlog_info \"Run 'pt help' for usage.\"\nexit $EXIT_USAGE_ERROR\n```\n\n## Documentation in Help\n```bash\ncmd_help() {\n    cat \u003c\u003c 'EOF'\n...\n\nEXIT CODES\n  0   Success\n  1   Usage error (bad arguments)\n  2   No candidates found\n  3   User cancelled\n  10  gum not available\n  20  Kill operation failed\n  30  Network error (update)\n  31  Checksum mismatch (update)\n  90  Internal error (bug)\nEOF\n}\n```\n\n## Benefits\n1. **Scripting**: `pt scan; case $? in 2) echo \"System clean\";; esac`\n2. **CI/CD**: Different handling for different failures\n3. **Debugging**: Know what went wrong without parsing output\n4. **Consistency**: Same meaning every time\n\n## Success Criteria\n- [ ] All exit codes defined as readonly constants\n- [ ] Every exit statement uses a constant\n- [ ] Exit codes documented in help\n- [ ] README includes exit code reference\n- [ ] No raw exit 1 statements remain","status":"open","priority":2,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:40:16.838311908-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:40:16.838311908-05:00","dependencies":[{"issue_id":"process_triage-y1z","depends_on_id":"process_triage-8ng","type":"blocks","created_at":"2026-01-14T22:40:50.649458071-05:00","created_by":"Dicklesworthstone"}]}
{"id":"process_triage-y8e","title":"Console Output Styling Enhancement","description":"## Overview\nUpgrade pt's console output system to match the quality standards established in repo_updater and giil projects.\n\n## Current State\n- pt uses gum for UI but has NO fallback when gum is unavailable\n- No TTY detection - colors may break in non-interactive environments\n- No NO_COLOR environment variable support (accessibility standard)\n- Logging functions exist but lack consistent emoji prefixes and color coding\n\n## Target State\nImplement a 3-tier fallback system:\n1. **Tier 1: gum** - Beautiful styled output with borders/spinners when available\n2. **Tier 2: ANSI** - Colored text with emoji prefixes when TTY detected\n3. **Tier 3: Plain** - No formatting for pipes, CI, or NO_COLOR environments\n\n## Rationale\n- **Accessibility**: NO_COLOR is a recognized standard (https://no-color.org/)\n- **CI Compatibility**: GitHub Actions and other CI systems need clean output\n- **Graceful Degradation**: Tool should work everywhere, look best where possible\n- **Consistency**: Match the UX quality of our other bash tools\n\n## Implementation Pattern (from repo_updater)\n```bash\nif [[ -t 2 ]] \u0026\u0026 [[ -z \"${NO_COLOR:-}\" ]]; then\n    RED='\\033[0;31m'\n    GREEN='\\033[0;32m'\n    # etc...\nelse\n    RED='' GREEN='' YELLOW='' # Disable all color\nfi\n```\n\n## Success Criteria\n- [ ] Works in interactive terminal with full styling\n- [ ] Works in CI environments without ANSI garbage\n- [ ] Respects NO_COLOR environment variable\n- [ ] All log output goes to stderr (stdout reserved for data)\n- [ ] Consistent emoji prefix scheme across all log levels","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:31:04.083856408-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:31:04.083856408-05:00"}
{"id":"process_triage-zbd","title":"Add E2E test for main pt workflow","description":"## Purpose\nCreate comprehensive end-to-end tests that verify the complete pt workflow from scan through kill, including decision memory persistence.\n\n## Parent Epic\nExpanded Test Coverage (process_triage-bgd)\n\n## Depends On\n- Test helper with mock injection (process_triage-h2y)\n\n## Why E2E Tests Are Critical\nUnit tests verify individual functions work. E2E tests verify:\n- Components integrate correctly\n- Data flows through the entire pipeline\n- User-visible behavior matches expectations\n- Real-world scenarios work end-to-end\n\n## Test Scenarios\n\n### test/test_e2e_workflow.bats\n\n```bash\n#\\!/usr/bin/env bats\n\nload 'test_helper/common'\n\nsetup() {\n    setup_test_env\n    test_start \"$BATS_TEST_NAME\" \"E2E workflow test\"\n}\n\nteardown() {\n    test_end \"$BATS_TEST_NAME\" \"${BATS_TEST_COMPLETED:-fail}\"\n    restore_path\n    teardown_test_env\n}\n\n#==============================================================================\n# SCAN WORKFLOW TESTS\n#==============================================================================\n\n@test \"E2E: scan finds stuck test runner and scores correctly\" {\n    test_info \"Setting up: mock ps with stuck bun test process\"\n    \n    # Create mock ps with a stuck test\n    create_mock_ps \"$(mock_ps_with_stuck_test 7200)\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    test_info \"Exit code: $status\"\n    test_info \"Output lines: $(echo \"$output\" | wc -l)\"\n    \n    # Verify exit code\n    assert_equals \"0\" \"$status\" \"pt scan should succeed\"\n    \n    # Verify stuck test is detected\n    assert_contains \"$output\" \"bun test\" \"Should find bun test process\"\n    \n    # Verify scoring (should be KILL or REVIEW based on age)\n    assert_contains \"$output\" \"KILL\\|REVIEW\" \"Should recommend action\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: scan with no candidates shows clean message\" {\n    test_info \"Setting up: mock ps with only short-lived processes\"\n    \n    # Create mock ps with only recent/protected processes\n    create_mock_ps \"$(mock_process 1000 1 1800 64 'vim file.txt')\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    test_info \"Exit code: $status\"\n    \n    # Should succeed but indicate no candidates\n    assert_equals \"0\" \"$status\" \"pt scan should succeed\"\n    \n    # Output should indicate no candidates or be empty\n    test_info \"Verifying output indicates no candidates\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: scan excludes protected system processes\" {\n    test_info \"Setting up: mock ps with system processes\"\n    \n    create_mock_ps \"\\\n$(mock_process 1 0 9999999 100 '/usr/lib/systemd/systemd')\n$(mock_process 2000 1 9999999 50 'sshd: user@pts/0')\n$(mock_process 3000 1 9999999 30 '/usr/sbin/cron')\n$(mock_process 4000 1000 200000 512 'bun test --watch')\n\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    # Should NOT include protected processes\n    assert_not_contains \"$output\" \"systemd\" \"Should not flag systemd\"\n    assert_not_contains \"$output\" \"sshd\" \"Should not flag sshd\"\n    assert_not_contains \"$output\" \"cron\" \"Should not flag cron\"\n    \n    # Should include the test runner\n    assert_contains \"$output\" \"bun test\" \"Should flag stuck test\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: scan with mixed processes sorts by score\" {\n    test_info \"Setting up: mock ps with mixed scenarios\"\n    \n    create_mock_ps \"$(mock_ps_mixed_scenario)\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    test_info \"Verifying score-based ordering\"\n    \n    # Higher-scored items should appear first\n    # Orphan + old should score higher than just old\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# DECISION MEMORY INTEGRATION TESTS\n#==============================================================================\n\n@test \"E2E: decision memory persists across invocations\" {\n    skip_if_no_jq\n    \n    test_info \"Setting up: save a kill decision\"\n    \n    # Manually write a decision\n    echo '{\"bun test --watch\": \"kill\"}' \u003e \"${CONFIG_DIR}/decisions.json\"\n    \n    test_info \"Verifying decision file exists\"\n    [[ -f \"${CONFIG_DIR}/decisions.json\" ]]\n    \n    test_info \"Running: pt history\"\n    run \"$PT_SCRIPT\" history\n    \n    # Should show the saved decision\n    assert_contains \"$output\" \"bun test\" \"History should show saved pattern\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: past kill decision increases score\" {\n    skip_if_no_jq\n    \n    test_info \"Setting up: decision memory with kill pattern\"\n    \n    # Save a kill decision for a pattern\n    echo '{\"bun test\": \"kill\"}' \u003e \"${CONFIG_DIR}/decisions.json\"\n    \n    # Create process matching that pattern\n    create_mock_ps \"$(mock_process 12345 1000 4000 100 'bun test --watch')\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    # The process should get boosted score due to past kill decision\n    # This is hard to verify directly without seeing the score\n    # But we can verify it's flagged\n    assert_contains \"$output\" \"bun test\" \"Process should be flagged\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: past spare decision decreases score\" {\n    skip_if_no_jq\n    \n    test_info \"Setting up: decision memory with spare pattern\"\n    \n    # Save a spare decision\n    echo '{\"gunicorn\": \"spare\"}' \u003e \"${CONFIG_DIR}/decisions.json\"\n    \n    # Create a gunicorn process that would normally be flagged\n    create_mock_ps \"$(mock_process 12345 1000 100000 200 'gunicorn --workers 4')\"\n    use_mock_bin\n    \n    test_info \"Running: pt scan\"\n    run \"$PT_SCRIPT\" scan\n    \n    # With spare decision, score should be lower\n    # May not appear at all, or should be SPARE recommendation\n    test_info \"Verifying spare decision affects scoring\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: clear command removes all decisions\" {\n    skip_if_no_jq\n    \n    test_info \"Setting up: populate decision memory\"\n    \n    echo '{\"pattern1\": \"kill\", \"pattern2\": \"spare\", \"pattern3\": \"kill\"}' \u003e \"${CONFIG_DIR}/decisions.json\"\n    \n    # Verify decisions exist\n    local count_before\n    count_before=$(jq 'length' \"${CONFIG_DIR}/decisions.json\")\n    test_info \"Decisions before clear: $count_before\"\n    assert_equals \"3\" \"$count_before\" \"Should have 3 decisions\"\n    \n    test_info \"Running: pt clear (with mocked confirmation)\"\n    # Need to mock gum confirm or run in non-interactive mode\n    echo 'y' | \"$PT_SCRIPT\" clear 2\u003e/dev/null || true\n    \n    # Verify decisions cleared\n    local count_after\n    count_after=$(jq 'length' \"${CONFIG_DIR}/decisions.json\")\n    test_info \"Decisions after clear: $count_after\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# HELP AND VERSION TESTS\n#==============================================================================\n\n@test \"E2E: help command shows all subcommands\" {\n    test_info \"Running: pt help\"\n    run \"$PT_SCRIPT\" help\n    \n    assert_equals \"0\" \"$status\" \"Help should succeed\"\n    \n    # Verify all commands documented\n    assert_contains \"$output\" \"scan\" \"Should document scan command\"\n    assert_contains \"$output\" \"history\" \"Should document history command\"\n    assert_contains \"$output\" \"clear\" \"Should document clear command\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: version command shows version number\" {\n    test_info \"Running: pt --version\"\n    run \"$PT_SCRIPT\" --version\n    \n    assert_equals \"0\" \"$status\" \"Version should succeed\"\n    assert_contains \"$output\" \"pt version\" \"Should show version prefix\"\n    \n    # Verify semver format\n    [[ \"$output\" =~ [0-9]+\\.[0-9]+\\.[0-9]+ ]]\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: unknown command shows error and hint\" {\n    test_info \"Running: pt unknowncommand\"\n    run \"$PT_SCRIPT\" unknowncommand\n    \n    # Should fail\n    [[ $status -ne 0 ]]\n    \n    # Should show helpful message\n    assert_contains \"$output\" \"Unknown\\|unknown\\|help\" \"Should hint at help\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n#==============================================================================\n# CONFIGURATION TESTS\n#==============================================================================\n\n@test \"E2E: respects PROCESS_TRIAGE_CONFIG environment variable\" {\n    test_info \"Setting up: custom config directory\"\n    \n    local custom_config=\"${TEST_DIR}/custom_config\"\n    mkdir -p \"$custom_config\"\n    \n    export PROCESS_TRIAGE_CONFIG=\"$custom_config\"\n    \n    test_info \"Running: pt history (should use custom config)\"\n    run \"$PT_SCRIPT\" history\n    \n    # Should succeed and potentially create files in custom location\n    assert_equals \"0\" \"$status\" \"Should succeed with custom config\"\n    \n    BATS_TEST_COMPLETED=pass\n}\n\n@test \"E2E: creates config directory if missing\" {\n    test_info \"Setting up: empty config path\"\n    \n    local new_config=\"${TEST_DIR}/new_config_dir\"\n    export PROCESS_TRIAGE_CONFIG=\"$new_config\"\n    \n    # Verify doesn't exist\n    [[ \\! -d \"$new_config\" ]]\n    \n    test_info \"Running: pt (should create config dir)\"\n    run \"$PT_SCRIPT\" help  # Safe command that triggers init\n    \n    # Verify created (or would be created on first real operation)\n    \n    BATS_TEST_COMPLETED=pass\n}\n```\n\n## Setup Requirements\n\n### test/test_e2e_workflow.bats setup\n```bash\n# At top of file\nPT_SCRIPT=\"${BATS_TEST_DIRNAME}/../pt\"\n\n# Verify pt script exists\nsetup_file() {\n    if [[ \\! -x \"$PT_SCRIPT\" ]]; then\n        echo \"ERROR: pt script not found at $PT_SCRIPT\" \u003e\u00262\n        exit 1\n    fi\n}\n```\n\n## Success Criteria\n- [ ] Scan workflow tested end-to-end\n- [ ] Protected process exclusion verified\n- [ ] Decision memory persistence tested\n- [ ] Clear command tested\n- [ ] Help and version tested\n- [ ] Unknown command error handling tested\n- [ ] Configuration override tested\n- [ ] All tests have detailed logging\n- [ ] All tests log start/end with pass/fail","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-14T22:46:42.878971197-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-14T22:46:42.878971197-05:00","dependencies":[{"issue_id":"process_triage-zbd","depends_on_id":"process_triage-h2y","type":"blocks","created_at":"2026-01-14T22:50:29.019098458-05:00","created_by":"Dicklesworthstone"}]}
