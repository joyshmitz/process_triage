#!/usr/bin/env bash
#
# pt - Process Triage v2.0.0
# Bayesian-inspired zombie/abandoned process detection with evidence gathering
#
# Usage: pt [scan|deep|history|clear|help|robot|agent]
#
set -euo pipefail

# ══════════════════════════════════════════════════════════════════════════════
# Configuration
# ══════════════════════════════════════════════════════════════════════════════

readonly VERSION="2.0.0"
readonly CONFIG_DIR="${PROCESS_TRIAGE_CONFIG:-${XDG_CONFIG_HOME:-$HOME/.config}/process_triage}"
readonly DECISIONS_FILE="$CONFIG_DIR/decisions.json"
readonly PRIORS_FILE="$CONFIG_DIR/priors.json"
readonly LOG_FILE="$CONFIG_DIR/triage.log"

# ══════════════════════════════════════════════════════════════════════════════
# Terminal Detection
# ══════════════════════════════════════════════════════════════════════════════

# Detect if we're in an interactive terminal
IS_TTY=false
[[ -t 1 ]] && IS_TTY=true

# Detect if colors should be disabled
# NO_COLOR is a standard: https://no-color.org/
USE_COLOR=true
if [[ "$IS_TTY" != "true" ]] || [[ -n "${NO_COLOR:-}" ]]; then
    USE_COLOR=false
fi

# Detect CI environment
IS_CI=false
[[ -n "${CI:-}" ]] && IS_CI=true

# ══════════════════════════════════════════════════════════════════════════════
# Colors (conditional on terminal detection)
# ══════════════════════════════════════════════════════════════════════════════

if [[ "$USE_COLOR" == "true" ]]; then
    readonly C_KILL=$'\e[91m'      # Bright red
    readonly C_REVIEW=$'\e[93m'    # Bright yellow
    readonly C_SPARE=$'\e[92m'     # Bright green
    readonly C_DIM=$'\e[90m'       # Gray
    readonly C_BOLD=$'\e[1m'
    readonly C_RESET=$'\e[0m'
else
    readonly C_KILL=''
    readonly C_REVIEW=''
    readonly C_SPARE=''
    readonly C_DIM=''
    readonly C_BOLD=''
    readonly C_RESET=''
fi

# Scoring thresholds
readonly THRESHOLD_KILL=60
readonly THRESHOLD_REVIEW=30

# Process type expected lifetimes (seconds)
declare -A TYPE_LIFETIME=(
    [test]=1800        # 30 min - tests should complete quickly
    [dev_server]=259200 # 3 days - dev servers can run a while
    [agent]=43200      # 12 hours - agent sessions
    [shell]=3600       # 1 hour - shell wrappers
    [build]=7200       # 2 hours - builds
    [daemon]=0         # Never expires
    [unknown]=86400    # 1 day default
)

# ══════════════════════════════════════════════════════════════════════════════
# Gum Availability
# ══════════════════════════════════════════════════════════════════════════════

# Gum should only be used in interactive TTY, not in CI
GUM_AVAILABLE=false
if [[ "$IS_TTY" == "true" ]] && [[ "$IS_CI" != "true" ]] && command -v gum &>/dev/null; then
    GUM_AVAILABLE=true
fi

# ══════════════════════════════════════════════════════════════════════════════
# Dependency Management
# ══════════════════════════════════════════════════════════════════════════════

ensure_gum() {
    # Skip gum install in non-interactive or CI environments
    if [[ "$IS_TTY" != "true" ]] || [[ "$IS_CI" == "true" ]]; then
        return 0
    fi
    command -v gum &>/dev/null && { GUM_AVAILABLE=true; return 0; }
    echo "Installing gum..."
    if command -v apt-get &>/dev/null; then
        sudo mkdir -p /etc/apt/keyrings 2>/dev/null || true
        curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg 2>/dev/null
        echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | sudo tee /etc/apt/sources.list.d/charm.list >/dev/null
        sudo apt-get update -qq && sudo apt-get install -y gum
    elif command -v brew &>/dev/null; then
        brew install gum
    else
        local arch; arch=$(uname -m)
        [[ "$arch" == "x86_64" ]] && arch="amd64"
        [[ "$arch" == "aarch64" ]] && arch="arm64"
        curl -fsSL "https://github.com/charmbracelet/gum/releases/download/v0.14.1/gum_0.14.1_linux_${arch}.tar.gz" | sudo tar xz -C /usr/local/bin gum
    fi
    if command -v gum &>/dev/null; then
        GUM_AVAILABLE=true
    else
        echo "Failed to install gum (interactive features disabled)"
    fi
}

ensure_config() {
    mkdir -p "$CONFIG_DIR"
    [[ -s "$DECISIONS_FILE" ]] || echo '{}' > "$DECISIONS_FILE"
    [[ -s "$PRIORS_FILE" ]] || echo '{}' > "$PRIORS_FILE"
}

ensure_deps_for_json() {
    # Robot/agent mode should never require gum. Keep JSON output dependency-light.
    return 0
}

# ══════════════════════════════════════════════════════════════════════════════
# Utility Functions
# ══════════════════════════════════════════════════════════════════════════════

log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"; }

iso_timestamp() {
    # RFC3339-ish without timezone dependencies
    date -u '+%Y-%m-%dT%H:%M:%SZ'
}

format_duration() {
    local s=$1
    if ((s < 60)); then echo "${s}s"
    elif ((s < 3600)); then echo "$((s/60))m"
    elif ((s < 86400)); then echo "$((s/3600))h"
    else echo "$((s/86400))d"
    fi
}

format_memory() {
    local mb=$1
    if ((mb < 1024)); then echo "${mb}M"
    else printf "%.1fG" "$(echo "scale=1; $mb/1024" | bc)"
    fi
}

json_escape() {
    # Minimal JSON string escape (sufficient for process args and evidence)
    local s=${1-}
    s=${s//\\/\\\\}
    s=${s//\"/\\\"}
    s=${s//$'\n'/\\n}
    s=${s//$'\r'/\\r}
    s=${s//$'\t'/\\t}
    echo -n "$s"
}

split_csv() {
    # split_csv "1,2, 3" -> lines
    local s=${1-}
    s=${s// /}
    s=${s//,/\\n}
    printf '%b\n' "$s" | awk 'NF'
}

get_system_stats_compact() {
    # Output: load1 load5 load15|cores|mem_used|mem_total|procs
    local load1="" load5="" load15="" cores="" mem_used="" mem_total="" procs=""

    if [[ -r /proc/loadavg ]]; then
        read -r load1 load5 load15 _ < /proc/loadavg 2>/dev/null || true
    else
        # macOS fallback: parse "load averages: 1.23 4.56 7.89"
        local u
        u=$(uptime 2>/dev/null || true)
        if [[ "$u" == *"load average"* ]] || [[ "$u" == *"load averages"* ]]; then
            # Extract last 3 numbers in the line (best-effort)
            read -r load1 load5 load15 < <(printf '%s\n' "$u" | awk -F'load averages?:' '{print $2}' | tr -d ',' | awk '{print $(NF-2), $(NF-1), $NF}' 2>/dev/null || true)
        fi
    fi

    if command -v nproc &>/dev/null; then
        cores=$(nproc 2>/dev/null || true)
    elif command -v sysctl &>/dev/null; then
        cores=$(sysctl -n hw.ncpu 2>/dev/null || true)
    fi

    if command -v free &>/dev/null; then
        mem_used=$(free -h 2>/dev/null | awk '/^Mem:/ {print $3}' || true)
        mem_total=$(free -h 2>/dev/null | awk '/^Mem:/ {print $2}' || true)
    fi

    procs=$(pgrep -cu "$(whoami)" 2>/dev/null || echo "0")

    printf '%s %s %s|%s|%s|%s|%s\n' "${load1:-}" "${load5:-}" "${load15:-}" "${cores:-}" "${mem_used:-}" "${mem_total:-}" "${procs:-}"
}

# ══════════════════════════════════════════════════════════════════════════════
# Decision Memory & Learning
# ══════════════════════════════════════════════════════════════════════════════

DECISIONS_CACHE_FILE=""
DECISIONS_CACHE_LOADED=false

load_decisions_cache() {
    [[ "$DECISIONS_CACHE_LOADED" == "true" ]] && return 0
    DECISIONS_CACHE_LOADED=true
    command -v jq &>/dev/null || return 0
    [[ -s "$DECISIONS_FILE" ]] || return 0
    DECISIONS_CACHE_FILE=$(mktemp)
    jq -r 'to_entries[] | "\(.key)\t\(.value)"' "$DECISIONS_FILE" > "$DECISIONS_CACHE_FILE" 2>/dev/null || true
}

cleanup_cache() {
    [[ -n "$DECISIONS_CACHE_FILE" && -f "$DECISIONS_CACHE_FILE" ]] && rm -f "$DECISIONS_CACHE_FILE"
    return 0
}
trap cleanup_cache EXIT

get_cached_decision() {
    local pattern=$1
    [[ -z "$DECISIONS_CACHE_FILE" || ! -s "$DECISIONS_CACHE_FILE" ]] && { echo "unknown"; return; }
    local result
    result=$(grep -F -- "$pattern" "$DECISIONS_CACHE_FILE" 2>/dev/null | head -1 | cut -f2)
    echo "${result:-unknown}"
}

normalize_pattern() {
    echo "$1" | sed -E \
        -e 's/--port[= ]*[0-9]+/--port=PORT/g' \
        -e 's/:[0-9]{4,5}/:PORT/g' \
        -e 's/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/UUID/g' \
        -e 's/[0-9]{5,}//g' \
        -e 's|/tmp/[^ ]+|/tmp/TMP|g' \
        -e 's|shell-snapshot[^ ]*|shell-snapshot|g' \
        | tr -s ' ' | cut -c1-150
}

save_decision() {
    local pattern=$1 decision=$2
    command -v jq &>/dev/null || return 0
    local tmp; tmp=$(mktemp)
    jq --arg k "$pattern" --arg v "$decision" '.[$k] = $v' "$DECISIONS_FILE" > "$tmp" 2>/dev/null && mv "$tmp" "$DECISIONS_FILE"
    log "Decision: $decision for: $pattern"
}

# ══════════════════════════════════════════════════════════════════════════════
# Process Classification
# ══════════════════════════════════════════════════════════════════════════════

is_protected_cmd() {
    local cmd=${1-}

    [[ "$cmd" =~ (systemd|journald|logind|networkd|resolved|timesyncd) ]] ||
    [[ "$cmd" =~ (dockerd|containerd|dbus-daemon|avahi-daemon) ]] ||
    [[ "$cmd" =~ ^/usr/libexec/(upowerd|fwupd|power-profiles|rtkit|udisks|accounts-daemon|polkit) ]] ||
    [[ "$cmd" =~ ^/usr/(sbin|bin)/(NetworkManager|ModemManager|rsyslogd|tailscaled|sddm|smartd|cron) ]] ||
    [[ "$cmd" =~ ^/usr/lib/(polkit|postgresql|bluetooth) ]] ||
    [[ "$cmd" =~ ^/usr/bin/(pulseaudio|pipewire) ]] ||
    [[ "$cmd" =~ elasticsearch ]] ||
    [[ "$cmd" =~ ^sshd ]]
}

classify_process() {
    local cmd=$1

    # Test processes
    if [[ "$cmd" =~ (bun\ test|jest|vitest|pytest|cargo\ test|npm\ test|go\ test|rspec|mocha) ]]; then
        echo "test"
    # Dev servers
    elif [[ "$cmd" =~ (--hot|--watch|next\ dev|vite|webpack-dev|npm\ run\ dev|yarn\ dev|bun\ run\ dev) ]]; then
        echo "dev_server"
    # AI agents
    elif [[ "$cmd" =~ (claude|codex|gemini|copilot|cursor|aider) ]]; then
        echo "agent"
    # Shell wrappers (from agents)
    elif [[ "$cmd" =~ (shell-snapshot|/bin/sh\ -c|/bin/bash\ -c|zsh\ -c) ]]; then
        echo "shell"
    # Build processes
    elif [[ "$cmd" =~ (cargo\ build|npm\ run\ build|tsc|rustc|gcc|clang|make\ ) ]]; then
        echo "build"
    # System daemons
    elif [[ "$cmd" =~ (systemd|journald|dockerd|containerd|postgres|elasticsearch|redis|nginx|sshd|cron) ]]; then
        echo "daemon"
    else
        echo "unknown"
    fi
}

# ══════════════════════════════════════════════════════════════════════════════
# Evidence Gathering (Bayesian-inspired)
# ══════════════════════════════════════════════════════════════════════════════

# Check if process has I/O activity (strong evidence of life)
check_io_activity() {
    local pid=$1
    local io_file="/proc/$pid/io"
    [[ -r "$io_file" ]] || { echo "unknown"; return; }

    local read1 write1 read2 write2
    read1=$(awk '/read_bytes/ {print $2}' "$io_file" 2>/dev/null) || { echo "unknown"; return; }
    write1=$(awk '/write_bytes/ {print $2}' "$io_file" 2>/dev/null)

    sleep 0.5

    read2=$(awk '/read_bytes/ {print $2}' "$io_file" 2>/dev/null) || { echo "unknown"; return; }
    write2=$(awk '/write_bytes/ {print $2}' "$io_file" 2>/dev/null)

    if [[ "$read1" != "$read2" ]] || [[ "$write1" != "$write2" ]]; then
        echo "active"
    else
        echo "idle"
    fi
}

# Check if CPU time is increasing (evidence of progress)
check_cpu_progress() {
    local pid=$1
    local stat_file="/proc/$pid/stat"
    [[ -r "$stat_file" ]] || { echo "unknown"; return; }

    local cpu1 cpu2
    cpu1=$(awk '{print $14+$15}' "$stat_file" 2>/dev/null) || { echo "unknown"; return; }
    sleep 0.5
    cpu2=$(awk '{print $14+$15}' "$stat_file" 2>/dev/null) || { echo "unknown"; return; }

    if [[ "$cpu1" != "$cpu2" ]]; then
        echo "progressing"
    else
        echo "stalled"
    fi
}

# Check terminal session status
check_terminal_session() {
    local pid=$1 tty=$2

    [[ -z "$tty" || "$tty" == "?" ]] && { echo "detached"; return; }

    # Check if the TTY has an active who entry
    local tty_short="${tty#*/dev/}"
    if who | grep -q "$tty_short"; then
        echo "active_session"
    else
        echo "dead_session"
    fi
}

# Check for open network connections (evidence of service)
check_network_activity() {
    local pid=$1

    # Check for listening or established sockets
    local sockets
    sockets=$(ss -tnp 2>/dev/null | grep -c "pid=$pid," || echo "0")

    if ((sockets > 0)); then
        echo "connected"
    else
        echo "no_connections"
    fi
}

# Check if process has active children
check_children() {
    local pid=$1
    local children
    children=$(pgrep -P "$pid" 2>/dev/null | wc -l)

    if ((children > 0)); then
        # Check if any child is using CPU
        local active=0
        for cpid in $(pgrep -P "$pid" 2>/dev/null); do
            local cpu
            cpu=$(ps -p "$cpid" -o %cpu= 2>/dev/null | tr -d ' ' | cut -d. -f1)
            ((cpu > 5)) && ((active++))
        done
        if ((active > 0)); then
            echo "active_children:$children"
        else
            echo "idle_children:$children"
        fi
    else
        echo "no_children"
    fi
}

# Check memory behavior (growing = possibly leaking)
check_memory_trend() {
    local pid=$1
    local status_file="/proc/$pid/status"
    [[ -r "$status_file" ]] || { echo "unknown"; return; }

    local rss1 rss2
    rss1=$(awk '/VmRSS/ {print $2}' "$status_file" 2>/dev/null) || { echo "unknown"; return; }
    sleep 0.5
    rss2=$(awk '/VmRSS/ {print $2}' "$status_file" 2>/dev/null) || { echo "unknown"; return; }

    local diff=$((rss2 - rss1))
    if ((diff > 1000)); then
        echo "growing"
    elif ((diff < -1000)); then
        echo "shrinking"
    else
        echo "stable"
    fi
}

# Check what the process is waiting on
check_wait_channel() {
    local pid=$1
    local wchan_file="/proc/$pid/wchan"
    [[ -r "$wchan_file" ]] || { echo "unknown"; return; }

    local wchan
    wchan=$(cat "$wchan_file" 2>/dev/null) || { echo "unknown"; return; }

    case "$wchan" in
        *futex*|*poll*|*select*) echo "waiting_io" ;;
        *sleep*) echo "sleeping" ;;
        *wait*) echo "waiting_child" ;;
        0|"") echo "running" ;;
        *) echo "waiting:$wchan" ;;
    esac
}

# ══════════════════════════════════════════════════════════════════════════════
# Bayesian Scoring Engine
# ══════════════════════════════════════════════════════════════════════════════

score_process_bayesian() {
    local pid=$1 ppid=$2 age=$3 mem=$4 cpu=$5 tty=$6 cmd=$7
    local deep_scan=${8:-false}

    local score=0
    local evidence=()
    local confidence="medium"

    # Classify the process type
    local ptype
    ptype=$(classify_process "$cmd")
    local expected_lifetime=${TYPE_LIFETIME[$ptype]:-86400}

    # ═══════════════════════════════════════════════════════════════════════
    # Prior probability based on type (Bayesian prior)
    # ═══════════════════════════════════════════════════════════════════════

    case "$ptype" in
        test)      ((score += 25)); evidence+=("test_process") ;;
        shell)     ((score += 20)); evidence+=("shell_wrapper") ;;
        agent)     ((score += 15)); evidence+=("ai_agent") ;;
        dev_server) ((score += 10)); evidence+=("dev_server") ;;
        build)     ((score += 15)); evidence+=("build_proc") ;;
        daemon)    ((score -= 100)); evidence+=("daemon:protected") ;;
    esac

    # ═══════════════════════════════════════════════════════════════════════
    # Age-based evidence (relative to expected lifetime)
    # ═══════════════════════════════════════════════════════════════════════

    if ((expected_lifetime > 0)); then
        local age_ratio=$((age * 100 / expected_lifetime))
        if ((age_ratio > 400)); then
            ((score += 50)); evidence+=("age:${age_ratio}%_expected")
            confidence="high"
        elif ((age_ratio > 200)); then
            ((score += 35)); evidence+=("age:${age_ratio}%_expected")
        elif ((age_ratio > 100)); then
            ((score += 20)); evidence+=("age:over_expected")
        fi
    fi

    # Absolute age thresholds
    local hours=$((age / 3600))
    if ((hours > 168)); then
        ((score += 40)); evidence+=(">1_week")
        confidence="high"
    elif ((hours > 48)); then
        ((score += 25)); evidence+=(">2_days")
    elif ((hours > 24)); then
        ((score += 15)); evidence+=(">1_day")
    fi

    # ═══════════════════════════════════════════════════════════════════════
    # Orphan detection (strong evidence)
    # ═══════════════════════════════════════════════════════════════════════

    if [[ "$ppid" == "1" ]] && [[ "$ptype" != "daemon" ]]; then
        ((score += 35)); evidence+=("orphaned:PPID=1")
        confidence="high"
    fi

    # ═══════════════════════════════════════════════════════════════════════
    # CPU pattern analysis
    # ═══════════════════════════════════════════════════════════════════════

    local cpu_int=${cpu%.*}
    cpu_int=${cpu_int:-0}

    if ((cpu_int >= 95 && hours > 6)); then
        ((score += 30)); evidence+=("stuck:99%_cpu_${hours}h")
        confidence="high"
    elif ((cpu_int >= 90 && hours > 2)); then
        ((score += 20)); evidence+=("high_cpu:${cpu_int}%")
    elif ((cpu_int == 0 && hours > 2)); then
        ((score += 25)); evidence+=("idle:0%_cpu")
    fi

    # ═══════════════════════════════════════════════════════════════════════
    # Memory analysis
    # ═══════════════════════════════════════════════════════════════════════

    if ((mem > 8000 && hours > 12)); then
        ((score += 20)); evidence+=("memory_hog:${mem}MB")
    elif ((mem > 4000 && hours > 24)); then
        ((score += 15)); evidence+=("high_mem:${mem}MB")
    fi

    # ═══════════════════════════════════════════════════════════════════════
    # Command pattern evidence
    # ═══════════════════════════════════════════════════════════════════════

    # Shell snapshot = leftover from agent
    if [[ "$cmd" =~ shell-snapshot ]]; then
        ((score += 30)); evidence+=("agent_shell_leftover")
    fi

    # Specific stuck patterns
    if [[ "$cmd" =~ (bun\ test|vitest|jest) ]] && ((age > 3600)); then
        ((score += 35)); evidence+=("stuck_test:${hours}h")
        confidence="high"
    fi

    if [[ "$cmd" =~ gemini.*--yolo ]] && ((hours > 24)); then
        ((score += 30)); evidence+=("old_gemini_yolo")
    fi

    # ═══════════════════════════════════════════════════════════════════════
    # Deep scan: gather runtime evidence (slower but more accurate)
    # ═══════════════════════════════════════════════════════════════════════

    if [[ "$deep_scan" == "true" ]]; then
        # I/O activity check
        local io_status
        io_status=$(check_io_activity "$pid")
        case "$io_status" in
            active) ((score -= 25)); evidence+=("io:active") ;;
            idle)   ((score += 20)); evidence+=("io:idle") ;;
        esac

        # CPU progress check
        local cpu_progress
        cpu_progress=$(check_cpu_progress "$pid")
        case "$cpu_progress" in
            progressing) ((score -= 20)); evidence+=("cpu:progressing") ;;
            stalled)     ((score += 25)); evidence+=("cpu:stalled") ;;
        esac

        # Terminal session check
        local session_status
        session_status=$(check_terminal_session "$pid" "$tty")
        case "$session_status" in
            active_session) ((score -= 20)); evidence+=("tty:active") ;;
            dead_session)   ((score += 20)); evidence+=("tty:dead") ;;
            detached)       ((score += 10)); evidence+=("tty:detached") ;;
        esac

        # Children check
        local children_status
        children_status=$(check_children "$pid")
        case "$children_status" in
            active_children*) ((score -= 15)); evidence+=("children:active") ;;
            idle_children*)   ((score += 10)); evidence+=("children:idle") ;;
            no_children)      ;; # Neutral
        esac

        # Network activity
        local net_status
        net_status=$(check_network_activity "$pid")
        case "$net_status" in
            connected) ((score -= 20)); evidence+=("net:connected") ;;
        esac

        confidence="high"
    fi

    # ═══════════════════════════════════════════════════════════════════════
    # Historical learning (Bayesian update from past decisions)
    # ═══════════════════════════════════════════════════════════════════════

    local pattern
    pattern=$(normalize_pattern "$cmd")
    local past_decision
    past_decision=$(get_cached_decision "$pattern")

    case "$past_decision" in
        kill)
            ((score += 30)); evidence+=("history:killed_before")
            confidence="high"
            ;;
        spare)
            ((score -= 40)); evidence+=("history:spared_before")
            ;;
    esac

    # ═══════════════════════════════════════════════════════════════════════
    # Protected patterns (never flag)
    # ═══════════════════════════════════════════════════════════════════════

    if is_protected_cmd "$cmd"; then
        ((score -= 200))
        evidence=("protected:system_service")
    fi

    # ═══════════════════════════════════════════════════════════════════════
    # Determine recommendation
    # ═══════════════════════════════════════════════════════════════════════

    local rec
    if ((score >= THRESHOLD_KILL)); then
        rec="KILL"
    elif ((score >= THRESHOLD_REVIEW)); then
        rec="REVIEW"
    else
        rec="SPARE"
    fi

    # Build evidence string
    local evidence_str
    evidence_str=$(IFS="|"; echo "${evidence[*]}")

    echo "$score|$rec|$confidence|$ptype|$evidence_str"
}

# ══════════════════════════════════════════════════════════════════════════════
# Process Collection
# ══════════════════════════════════════════════════════════════════════════════

collect_candidates() {
    local min_age=${1:-3600}
    local deep_scan=${2:-false}
    local candidates=()

    load_decisions_cache

    # Get processes with CPU and TTY info
    local procs
    procs=$(ps -eo pid,ppid,etimes,rss,%cpu,tty,args --no-headers -u "$(whoami)" 2>/dev/null | awk -v min="$min_age" '
        $3 >= min &&
        $7 !~ /systemd/ &&
        $7 !~ /^sshd/ &&
        $7 !~ /dockerd/ &&
        $7 !~ /containerd/ &&
        $7 !~ /dbus-daemon/ &&
        $7 !~ /journald|logind|networkd|resolved/ &&
        $7 !~ /^\/usr\/bin\/(pulseaudio|pipewire)/
        {
            # pid|ppid|age|mem_mb|cpu|tty|cmd
            print $1 "|" $2 "|" $3 "|" int($4/1024) "|" $5 "|" $6 "|" substr($0, index($0,$7))
        }
    ')

    while IFS='|' read -r pid ppid age mem cpu tty cmd; do
        [[ -z "$pid" ]] && continue

        local result
        result=$(score_process_bayesian "$pid" "$ppid" "$age" "${mem:-0}" "${cpu:-0}" "${tty:-?}" "$cmd" "$deep_scan")

        local score rec confidence ptype evidence
        IFS='|' read -r score rec confidence ptype evidence <<< "$result"

        # Only include if score > 0
        ((score > 0)) && candidates+=("$(printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s' \
            "$score" "$pid" "$ppid" "$age" "${mem:-0}" "${cpu:-0}" "${tty:-?}" "$rec" "$confidence" "$ptype" "$evidence" "$cmd")")
    done <<< "$procs"

    printf '%s\n' "${candidates[@]}" | sort -t$'\t' -k1 -nr
}

# ══════════════════════════════════════════════════════════════════════════════
# UI Components
# ══════════════════════════════════════════════════════════════════════════════

show_header() {
    clear
    gum style \
        --border rounded \
        --border-foreground 99 \
        --padding "0 2" \
        --margin "0 0 1 0" \
        "$(gum style --foreground 99 --bold '  Process Triage')" \
        "$(gum style --foreground 245 "  v$VERSION • Bayesian Evidence Engine")"
}

show_system_stats() {
    local load; load=$(cut -d' ' -f1-3 < /proc/loadavg)
    local cores; cores=$(nproc)
    local mem_info; mem_info=$(free -h | awk '/^Mem:/ {printf "%s / %s", $3, $2}')
    local procs; procs=$(pgrep -cu "$(whoami)")

    gum style --foreground 245 "  Load: $load ($cores cores)  │  Memory: $mem_info  │  Procs: $procs"
    echo
}

format_evidence() {
    local evidence=$1
    local formatted=""

    # Parse evidence items and format nicely
    IFS='|' read -ra items <<< "$evidence"
    for item in "${items[@]}"; do
        case "$item" in
            *protected*) formatted+="${C_SPARE}◆${C_RESET}" ;;
            *killed_before*) formatted+="${C_KILL}◆${C_RESET}" ;;
            *spared_before*) formatted+="${C_SPARE}◆${C_RESET}" ;;
            *orphaned*) formatted+="${C_KILL}○${C_RESET}" ;;
            *stuck*) formatted+="${C_KILL}!${C_RESET}" ;;
            *io:active*) formatted+="${C_SPARE}↔${C_RESET}" ;;
            *io:idle*) formatted+="${C_REVIEW}⊘${C_RESET}" ;;
            *cpu:progressing*) formatted+="${C_SPARE}↻${C_RESET}" ;;
            *cpu:stalled*) formatted+="${C_KILL}⊗${C_RESET}" ;;
            *tty:active*) formatted+="${C_SPARE}●${C_RESET}" ;;
            *tty:dead*) formatted+="${C_KILL}○${C_RESET}" ;;
            *age:*) formatted+="${C_REVIEW}⏱${C_RESET}" ;;
            *memory*) formatted+="${C_REVIEW}▣${C_RESET}" ;;
        esac
    done

    echo "$formatted"
}

# ══════════════════════════════════════════════════════════════════════════════
# Robot/Agent Mode (No TUI)
# ══════════════════════════════════════════════════════════════════════════════

robot_help() {
    cat << 'EOF'
pt robot - Agent-optimized interface (no TUI)

USAGE
    pt robot [plan|apply|explain] [options]
    pt agent [plan|apply|explain] [options]   # alias

PLAN (scan + recommended actions)
    pt robot plan [--deep] [--min-age SECONDS] [--format json|md] [--only all|kill|review|spare] [--limit N]

APPLY (execute without TUI)
    pt robot apply --recommended [--deep] [--min-age SECONDS] [--yes] [--format json|md]
    pt robot apply --pids 123,456 [--yes] [--format json|md]

EXPLAIN (single PID)
    pt robot explain --pid 123 [--deep] [--format json|md]

NOTES
    - Default output is JSON (token-efficient for coding agents).
    - Destructive actions require explicit --yes. (Interactive TUI confirmation remains the default in non-robot mode.)
EOF
}

robot_emit_plan_json() {
    local deep=$1 min_age=$2 only=$3 limit=$4
    local now; now=$(iso_timestamp)

    local sys
    sys=$(get_system_stats_compact)

    local candidates=()
    mapfile -t candidates < <(collect_candidates "$min_age" "$deep")

    local kill_count=0 review_count=0 spare_count=0 total=0
    local kill_pids=() review_pids=() spare_pids=()

    # Pre-filter + limit
    local filtered=()
    local c
    for c in "${candidates[@]}"; do
        [[ -z "$c" ]] && continue
        local score pid ppid age mem cpu tty rec confidence ptype evidence cmd
        IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$c"

        case "$only" in
            kill) [[ "$rec" != "KILL" ]] && continue ;;
            review) [[ "$rec" != "REVIEW" ]] && continue ;;
            spare) [[ "$rec" != "SPARE" ]] && continue ;;
            all|"") ;;
            *) ;;
        esac

        filtered+=("$c")
        if ((limit > 0 && ${#filtered[@]} >= limit)); then
            break
        fi
    done

    # Count + pid lists (from filtered set)
    for c in "${filtered[@]}"; do
        [[ -z "$c" ]] && continue
        local score pid ppid age mem cpu tty rec confidence ptype evidence cmd
        IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$c"
        ((total++))
        case "$rec" in
            KILL) ((kill_count++)); kill_pids+=("$pid") ;;
            REVIEW) ((review_count++)); review_pids+=("$pid") ;;
            SPARE) ((spare_count++)); spare_pids+=("$pid") ;;
        esac
    done

    # Emit JSON
    printf '{'
    printf '"version":"%s",' "$(json_escape "$VERSION")"
    printf '"mode":"robot_plan",'
    printf '"generated_at":"%s",' "$(json_escape "$now")"
    printf '"deep":%s,' "$deep"
    printf '"min_age_s":%s,' "$min_age"

    # system
    local load cores mem_used mem_total procs
    IFS='|' read -r load cores mem_used mem_total procs <<< "$sys"
    # load is "l1 l5 l15"
    local l1 l5 l15
    read -r l1 l5 l15 <<< "${load:-}"
    printf '"system":{'
    printf '"user":"%s",' "$(json_escape "$(whoami)")"
    printf '"cores":"%s",' "$(json_escape "${cores:-}")"
    printf '"loadavg":["%s","%s","%s"],' "$(json_escape "${l1:-}")" "$(json_escape "${l5:-}")" "$(json_escape "${l15:-}")"
    printf '"mem_used":"%s",' "$(json_escape "${mem_used:-}")"
    printf '"mem_total":"%s",' "$(json_escape "${mem_total:-}")"
    printf '"proc_count":"%s"' "$(json_escape "${procs:-}")"
    printf '},'

    # summary
    printf '"summary":{"candidates":%s,"kill":%s,"review":%s,"spare":%s},' "$total" "$kill_count" "$review_count" "$spare_count"

    # recommended pids (preselected = kill_pids)
    printf '"recommended":{'
    printf '"preselected_pids":['
    local i
    for i in "${!kill_pids[@]}"; do
        ((i > 0)) && printf ','
        printf '%s' "${kill_pids[$i]}"
    done
    printf '],'
    printf '"kill_pids":['
    for i in "${!kill_pids[@]}"; do
        ((i > 0)) && printf ','
        printf '%s' "${kill_pids[$i]}"
    done
    printf '],'
    printf '"review_pids":['
    for i in "${!review_pids[@]}"; do
        ((i > 0)) && printf ','
        printf '%s' "${review_pids[$i]}"
    done
    printf '],'
    printf '"spare_pids":['
    for i in "${!spare_pids[@]}"; do
        ((i > 0)) && printf ','
        printf '%s' "${spare_pids[$i]}"
    done
    printf ']'
    printf '},'

    # candidates
    printf '"candidates":['
    local first=1
    for c in "${filtered[@]}"; do
        [[ -z "$c" ]] && continue
        local score pid ppid age mem cpu tty rec confidence ptype evidence cmd
        IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$c"

        ((first == 0)) && printf ','
        first=0

        local age_h mem_h
        age_h=$(format_duration "${age:-0}")
        mem_h=$(format_memory "${mem:-0}")

        printf '{'
        printf '"pid":%s,' "$pid"
        printf '"ppid":%s,' "$ppid"
        printf '"score":%s,' "$score"
        printf '"rec":"%s",' "$(json_escape "$rec")"
        printf '"preselected":%s,' "$([[ "$rec" == "KILL" ]] && echo "true" || echo "false")"
        printf '"confidence":"%s",' "$(json_escape "$confidence")"
        printf '"type":"%s",' "$(json_escape "$ptype")"
        printf '"age_s":%s,' "$age"
        printf '"age_h":"%s",' "$(json_escape "$age_h")"
        printf '"mem_mb":%s,' "$mem"
        printf '"mem_h":"%s",' "$(json_escape "$mem_h")"
        printf '"cpu":"%s",' "$(json_escape "$cpu")"
        printf '"tty":"%s",' "$(json_escape "$tty")"

        # evidence array
        printf '"evidence":['
        local ev=()
        IFS='|' read -ra ev <<< "$evidence"
        for i in "${!ev[@]}"; do
            ((i > 0)) && printf ','
            printf '"%s"' "$(json_escape "${ev[$i]}")"
        done
        printf '],'

        printf '"cmd":"%s"' "$(json_escape "$cmd")"
        printf '}'
    done
    printf ']'

    printf '}\n'
}

robot_emit_plan_md() {
    local deep=$1 min_age=$2 only=$3 limit=$4
    local now; now=$(iso_timestamp)

    local sys
    sys=$(get_system_stats_compact)

    local candidates=()
    mapfile -t candidates < <(collect_candidates "$min_age" "$deep")

    local filtered=()
    local c
    for c in "${candidates[@]}"; do
        [[ -z "$c" ]] && continue
        local _score _pid _ppid _age _mem _cpu _tty _rec _confidence _ptype _evidence _cmd
        IFS=$'\t' read -r _score _pid _ppid _age _mem _cpu _tty _rec _confidence _ptype _evidence _cmd <<< "$c"
        case "$only" in
            kill) [[ "$_rec" != "KILL" ]] && continue ;;
            review) [[ "$_rec" != "REVIEW" ]] && continue ;;
            spare) [[ "$_rec" != "SPARE" ]] && continue ;;
            all|"") ;;
        esac
        filtered+=("$c")
        if ((limit > 0 && ${#filtered[@]} >= limit)); then
            break
        fi
    done

    local load cores mem_used mem_total procs
    IFS='|' read -r load cores mem_used mem_total procs <<< "$sys"

    printf '# pt robot plan\n\n'
    # shellcheck disable=SC2016
    printf -- '- generated_at: `%s`\n- deep: `%s`\n- min_age_s: `%s`\n- user: `%s`\n- loadavg: `%s`\n- cores: `%s`\n- mem: `%s / %s`\n- proc_count: `%s`\n\n' \
        "$now" "$deep" "$min_age" "$(whoami)" "${load:-}" "${cores:-}" "${mem_used:-}" "${mem_total:-}" "${procs:-}"

    printf '## Candidates\n\n'
    printf '| rec | score | pid | ppid | age | mem | cpu | tty | type | evidence | cmd |\n'
    printf '|---|---:|---:|---:|---:|---:|---:|---|---|---|---|\n'
    for c in "${filtered[@]}"; do
        [[ -z "$c" ]] && continue
        local score pid ppid age mem cpu tty rec confidence ptype evidence cmd
        IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$c"
        local age_h mem_h cmd_short evidence_short
        age_h=$(format_duration "${age:-0}")
        mem_h=$(format_memory "${mem:-0}")
        cmd_short=$(printf '%s' "$cmd" | cut -c1-60)
        [[ ${#cmd} -gt 60 ]] && cmd_short="${cmd_short}…"
        evidence_short=$(printf '%s' "${evidence//|/, }" | cut -c1-50)
        [[ ${#evidence_short} -gt 50 ]] && evidence_short="${evidence_short}…"
        # shellcheck disable=SC2016
        printf '| %s | %s | %s | %s | %s | %s | %s | %s | %s | %s | `%s` |\n' \
            "$rec" "$score" "$pid" "$ppid" "$age_h" "$mem_h" "$cpu" "$tty" "$ptype" "$evidence_short" "$cmd_short"
    done
}

robot_explain_pid_json() {
    local pid=$1 deep=$2

    local line
    line=$(ps -p "$pid" -o pid=,ppid=,etimes=,rss=,%cpu=,tty=,args= --no-headers 2>/dev/null || true)
    if [[ -z "$line" ]]; then
        printf '{"version":"%s","mode":"robot_explain","pid":%s,"error":"not_found"}\n' "$(json_escape "$VERSION")" "$pid"
        return 0
    fi

    local spid ppid age rss cpu tty cmd
    spid=$(printf '%s\n' "$line" | awk '{print $1}')
    ppid=$(printf '%s\n' "$line" | awk '{print $2}')
    age=$(printf '%s\n' "$line" | awk '{print $3}')
    rss=$(printf '%s\n' "$line" | awk '{print $4}')
    cpu=$(printf '%s\n' "$line" | awk '{print $5}')
    tty=$(printf '%s\n' "$line" | awk '{print $6}')
    cmd=$(printf '%s\n' "$line" | awk '{$1=$2=$3=$4=$5=$6=""; sub(/^ +/,""); print}')

    local mem_mb
    mem_mb=$((rss / 1024))

    local result score rec confidence ptype evidence
    result=$(score_process_bayesian "$spid" "$ppid" "$age" "$mem_mb" "$cpu" "$tty" "$cmd" "$deep")
    IFS='|' read -r score rec confidence ptype evidence <<< "$result"

    local now; now=$(iso_timestamp)
    local age_h mem_h
    age_h=$(format_duration "${age:-0}")
    mem_h=$(format_memory "${mem_mb:-0}")

    printf '{'
    printf '"version":"%s",' "$(json_escape "$VERSION")"
    printf '"mode":"robot_explain",'
    printf '"generated_at":"%s",' "$(json_escape "$now")"
    printf '"deep":%s,' "$deep"
    printf '"pid":%s,' "$spid"
    printf '"ppid":%s,' "$ppid"
    printf '"score":%s,' "$score"
    printf '"rec":"%s",' "$(json_escape "$rec")"
    printf '"confidence":"%s",' "$(json_escape "$confidence")"
    printf '"type":"%s",' "$(json_escape "$ptype")"
    printf '"age_s":%s,' "$age"
    printf '"age_h":"%s",' "$(json_escape "$age_h")"
    printf '"mem_mb":%s,' "$mem_mb"
    printf '"mem_h":"%s",' "$(json_escape "$mem_h")"
    printf '"cpu":"%s",' "$(json_escape "$cpu")"
    printf '"tty":"%s",' "$(json_escape "$tty")"
    printf '"evidence":['
    local ev=()
    IFS='|' read -ra ev <<< "$evidence"
    local i
    for i in "${!ev[@]}"; do
        ((i > 0)) && printf ','
        printf '"%s"' "$(json_escape "${ev[$i]}")"
    done
    printf '],'
    printf '"cmd":"%s"' "$(json_escape "$cmd")"
    printf '}\n'
}

robot_apply_json() {
    local deep=$1 min_age=$2 mode=$3 pids_csv=$4 yes=$5

    local now; now=$(iso_timestamp)
    local candidates=()
    local selected=()
    declare -A candidate_map_cmd=()

    if [[ "$mode" == "recommended" ]]; then
        mapfile -t candidates < <(collect_candidates "$min_age" "$deep")
        local c
        for c in "${candidates[@]}"; do
            [[ -z "$c" ]] && continue
            local score pid ppid age mem cpu tty rec confidence ptype evidence cmd
            IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$c"
            [[ "$rec" == "KILL" ]] && selected+=("$pid")
        done
    else
        mapfile -t selected < <(split_csv "$pids_csv")
    fi

    if [[ "${#selected[@]}" -eq 0 ]]; then
        printf '{"version":"%s","mode":"robot_apply","generated_at":"%s","deep":%s,"min_age_s":%s,"selected_pids":[],"note":"nothing_to_do"}\n' \
            "$(json_escape "$VERSION")" "$(json_escape "$now")" "$deep" "$min_age"
        return 0
    fi

    if [[ "$yes" != "true" ]]; then
        # Safety: require explicit --yes for destructive actions.
        printf '{"version":"%s","mode":"robot_apply","generated_at":"%s","deep":%s,"min_age_s":%s,"selected_pids":[' \
            "$(json_escape "$VERSION")" "$(json_escape "$now")" "$deep" "$min_age"
        local i
        for i in "${!selected[@]}"; do
            ((i > 0)) && printf ','
            printf '%s' "${selected[$i]}"
        done
        printf '],"error":"confirmation_required","hint":"re-run with --yes to execute"}\n'
        return 2
    fi

    local killed=0 failed=0 skipped=0
    local results=()

    # Build a map from pid -> cmd for learning when we scanned.
    if [[ "$mode" == "recommended" ]]; then
        local c
        for c in "${candidates[@]}"; do
            [[ -z "$c" ]] && continue
            local _score _pid _ppid _age _mem _cpu _tty _rec _confidence _ptype _evidence _cmd
            IFS=$'\t' read -r _score _pid _ppid _age _mem _cpu _tty _rec _confidence _ptype _evidence _cmd <<< "$c"
            candidate_map_cmd["$_pid"]="$_cmd"
        done
    fi

    local pid
    for pid in "${selected[@]}"; do
        [[ -z "$pid" ]] && continue

        # Skip self
        if [[ "$pid" == "$$" ]]; then
            results+=("{\"pid\":$pid,\"status\":\"skipped\",\"reason\":\"self\"}")
            ((skipped++))
            continue
        fi

        # Fetch cmd if not available
        local cmd=""
        if [[ "$mode" == "recommended" ]]; then
            cmd=${candidate_map_cmd["$pid"]:-}
        fi
        if [[ -z "$cmd" ]]; then
            cmd=$(ps -p "$pid" -o args= --no-headers 2>/dev/null || true)
        fi

        if [[ -n "$cmd" ]] && is_protected_cmd "$cmd"; then
            results+=("{\"pid\":$pid,\"status\":\"skipped\",\"reason\":\"protected\"}")
            ((skipped++))
            continue
        fi

        if ! kill -0 "$pid" 2>/dev/null; then
            results+=("{\"pid\":$pid,\"status\":\"skipped\",\"reason\":\"not_running\"}")
            ((skipped++))
            continue
        fi

        if kill "$pid" 2>/dev/null; then
            sleep 0.3
            if kill -0 "$pid" 2>/dev/null; then
                if kill -9 "$pid" 2>/dev/null; then
                    results+=("{\"pid\":$pid,\"status\":\"killed\",\"signal\":\"KILL\"}")
                    ((killed++))
                else
                    results+=("{\"pid\":$pid,\"status\":\"failed\",\"reason\":\"sigkill_failed\"}")
                    ((failed++))
                    continue
                fi
            else
                results+=("{\"pid\":$pid,\"status\":\"killed\",\"signal\":\"TERM\"}")
                ((killed++))
            fi
        elif kill -9 "$pid" 2>/dev/null; then
            results+=("{\"pid\":$pid,\"status\":\"killed\",\"signal\":\"KILL\"}")
            ((killed++))
        else
            results+=("{\"pid\":$pid,\"status\":\"failed\",\"reason\":\"signal_failed\"}")
            ((failed++))
            continue
        fi

        # Learning: record kill decisions when we can associate a stable pattern.
        if [[ -n "$cmd" ]]; then
            local pattern
            pattern=$(normalize_pattern "$cmd")
            save_decision "$pattern" "kill"
        fi
    done

    # Learning: if we scanned a full candidate set and chose recommended-only kills, record spares for the rest.
    if [[ "$mode" == "recommended" ]]; then
        local c
        for c in "${candidates[@]}"; do
            [[ -z "$c" ]] && continue
            local _score _pid _ppid _age _mem _cpu _tty _rec _confidence _ptype _evidence _cmd
            IFS=$'\t' read -r _score _pid _ppid _age _mem _cpu _tty _rec _confidence _ptype _evidence _cmd <<< "$c"
            if [[ "$_rec" != "KILL" ]]; then
                local pattern
                pattern=$(normalize_pattern "$_cmd")
                save_decision "$pattern" "spare"
            fi
        done
    fi

    printf '{'
    printf '"version":"%s",' "$(json_escape "$VERSION")"
    printf '"mode":"robot_apply",'
    printf '"generated_at":"%s",' "$(json_escape "$now")"
    printf '"deep":%s,' "$deep"
    printf '"min_age_s":%s,' "$min_age"
    printf '"requested":{"mode":"%s","pids_csv":"%s"},' "$(json_escape "$mode")" "$(json_escape "$pids_csv")"
    printf '"summary":{"killed":%s,"failed":%s,"skipped":%s},' "$killed" "$failed" "$skipped"
    printf '"results":['
    local i
    for i in "${!results[@]}"; do
        ((i > 0)) && printf ','
        printf '%s' "${results[$i]}"
    done
    printf ']'
    printf '}\n'
}

cmd_robot() {
    local sub=${1:-plan}
    if [[ "$sub" == "plan" || "$sub" == "apply" || "$sub" == "explain" ]]; then
        shift || true
    else
        sub="plan"
    fi

    local deep=false
    local min_age=3600
    local format="json"
    local only="all"
    local limit=0
    local yes="false"
    local recommended="false"
    local pids_csv=""
    local explain_pid=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --deep) deep=true; shift ;;
            --min-age) min_age=${2:-3600}; shift 2 ;;
            --format) format=${2:-json}; shift 2 ;;
            --json) format="json"; shift ;;
            --md|--markdown) format="md"; shift ;;
            --only) only=${2:-all}; shift 2 ;;
            --limit) limit=${2:-0}; shift 2 ;;
            --yes|--force) yes="true"; shift ;;
            --recommended) recommended="true"; shift ;;
            --pids) pids_csv=${2:-}; shift 2 ;;
            --pid) explain_pid=${2:-}; shift 2 ;;
            -h|--help) robot_help; return 0 ;;
            *) shift ;;
        esac
    done

    ensure_config
    ensure_deps_for_json

    case "$sub" in
        plan)
            if [[ "$format" == "md" ]]; then
                robot_emit_plan_md "$deep" "$min_age" "$only" "$limit"
            else
                robot_emit_plan_json "$deep" "$min_age" "$only" "$limit"
            fi
            ;;
        explain)
            [[ -z "$explain_pid" ]] && { robot_help; return 1; }
            if [[ "$format" == "md" ]]; then
                printf '```json\n'
                robot_explain_pid_json "$explain_pid" "$deep"
                printf '```\n'
            else
                robot_explain_pid_json "$explain_pid" "$deep"
            fi
            ;;
        apply)
            local mode="pids"
            if [[ "$recommended" == "true" ]]; then
                mode="recommended"
            fi
            robot_apply_json "$deep" "$min_age" "$mode" "$pids_csv" "$yes"
            ;;
        *)
            robot_help
            return 1
            ;;
    esac
}

# ══════════════════════════════════════════════════════════════════════════════
# Commands
# ══════════════════════════════════════════════════════════════════════════════

cmd_scan() {
    local deep=${1:-false}

    show_header
    show_system_stats

    local scan_msg="  Scanning processes..."
    [[ "$deep" == "true" ]] && scan_msg="  Deep scanning (gathering evidence)..."

    gum spin --spinner dot --title "$scan_msg" -- sleep 0.3

    local candidates=()
    mapfile -t candidates < <(collect_candidates 3600 "$deep")

    if [[ ${#candidates[@]} -eq 0 ]] || [[ -z "${candidates[0]}" ]]; then
        gum style --foreground 82 --bold "  ✓ No suspicious processes found"
        echo
        return 0
    fi

    # Count by recommendation
    local kill_count=0 review_count=0 spare_count=0
    for c in "${candidates[@]}"; do
        [[ -z "$c" ]] && continue
        local rec
        rec=$(echo "$c" | cut -d$'\t' -f8)
        case "$rec" in
            KILL) ((kill_count++)) ;;
            REVIEW) ((review_count++)) ;;
            SPARE) ((spare_count++)) ;;
        esac
    done

    echo
    gum style --foreground 245 "  Found ${#candidates[@]} candidates: ${C_KILL}$kill_count KILL${C_RESET} | ${C_REVIEW}$review_count REVIEW${C_RESET} | ${C_SPARE}$spare_count SPARE${C_RESET}"
    echo

    # Header
    printf "  %6s │ %5s │ %5s │ %5s │ %4s │ %8s │ %s\n" "STATUS" "PID" "AGE" "MEM" "CONF" "TYPE" "EVIDENCE → COMMAND"
    echo "  ───────┼───────┼───────┼───────┼──────┼──────────┼─────────────────────────────"

    for c in "${candidates[@]}"; do
        [[ -z "$c" ]] && continue

        IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$c"

        local age_fmt; age_fmt=$(format_duration "$age")
        local mem_fmt; mem_fmt=$(format_memory "$mem")
        local cmd_short; cmd_short=$(echo "$cmd" | cut -c1-35)
        [[ ${#cmd} -gt 35 ]] && cmd_short="${cmd_short}…"

        # Format confidence
        local conf_fmt
        case "$confidence" in
            high)   conf_fmt="${C_BOLD}HIGH${C_RESET}" ;;
            medium) conf_fmt="${C_DIM}MED${C_RESET}" ;;
            *)      conf_fmt="${C_DIM}LOW${C_RESET}" ;;
        esac

        # Color badge
        local badge
        case "$rec" in
            KILL)   badge="${C_KILL}KILL${C_RESET}" ;;
            REVIEW) badge="${C_REVIEW}REVIEW${C_RESET}" ;;
            SPARE)  badge="${C_SPARE}SPARE${C_RESET}" ;;
            *)      badge="${C_DIM}????${C_RESET}" ;;
        esac

        # Format evidence indicators
        local ev_fmt
        ev_fmt=$(format_evidence "$evidence")

        printf "  %6s │ %5s │ %5s │ %5s │ %4s │ %8s │ %s %s\n" \
            "$badge" "$pid" "$age_fmt" "$mem_fmt" "$conf_fmt" "$ptype" "$ev_fmt" "$cmd_short"
    done

    echo
    gum style --foreground 245 "  Legend: ${C_KILL}○${C_RESET}orphan ${C_KILL}!${C_RESET}stuck ${C_SPARE}↔${C_RESET}I/O ${C_KILL}⊗${C_RESET}stalled ${C_SPARE}●${C_RESET}tty ${C_REVIEW}⏱${C_RESET}age ${C_KILL}◆${C_RESET}killed ${C_SPARE}◆${C_RESET}spared"
    echo
    gum style --foreground 245 "  Run 'pt' for interactive mode or 'pt deep' for evidence gathering"
}

cmd_run() {
    local deep=${1:-false}

    show_header
    show_system_stats

    local scan_msg="  Scanning processes..."
    [[ "$deep" == "true" ]] && scan_msg="  Deep scanning (gathering runtime evidence)..."

    gum spin --spinner dot --title "$scan_msg" -- sleep 0.3

    local candidates=()
    mapfile -t candidates < <(collect_candidates 3600 "$deep")

    if [[ ${#candidates[@]} -eq 0 ]] || [[ -z "${candidates[0]}" ]]; then
        gum style --foreground 82 --bold "  ✓ System is clean"
        echo
        gum style --foreground 245 "  No suspicious processes found."
        echo
        return 0
    fi

    # Build selection items with evidence
    local items=()
    local preselect=()
    declare -A pid_map

    for c in "${candidates[@]}"; do
        [[ -z "$c" ]] && continue

        IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$c"

        local age_fmt; age_fmt=$(format_duration "$age")
        local mem_fmt; mem_fmt=$(format_memory "$mem")
        local cmd_short; cmd_short=$(echo "$cmd" | cut -c1-40)
        [[ ${#cmd} -gt 40 ]] && cmd_short="${cmd_short}…"

        # Format type
        local type_short
        case "$ptype" in
            test) type_short="TEST" ;;
            dev_server) type_short="DEV" ;;
            agent) type_short="AGENT" ;;
            shell) type_short="SHELL" ;;
            build) type_short="BUILD" ;;
            *) type_short="???" ;;
        esac

        # Build display line
        local line
        line=$(printf "[%-6s] %3d PID:%-7s %5s %5s %-5s │ %s" "$rec" "$score" "$pid" "$age_fmt" "$mem_fmt" "$type_short" "$cmd_short")

        items+=("$line")
        pid_map["$line"]="$c"

        # Pre-select KILL recommendations
        [[ "$rec" == "KILL" ]] && preselect+=("$line")
    done

    # Count categories
    echo
    gum style --foreground 245 "  ${#candidates[@]} candidates. Pre-selected: ${C_KILL}${#preselect[@]} KILL${C_RESET}"
    echo
    gum style --foreground 245 "  ${C_KILL}[KILL]${C_RESET}=kill  ${C_REVIEW}[REVIEW]${C_RESET}=check  ${C_SPARE}[SPARE]${C_RESET}=safe  │  Score reflects abandonment probability"
    echo

    # Interactive selection
    local selected
    if [[ ${#preselect[@]} -gt 0 ]]; then
        selected=$(printf '%s\n' "${items[@]}" | gum choose --no-limit --height 20 \
            --cursor-prefix "[ ] " --selected-prefix "[✓] " --unselected-prefix "[ ] " \
            --header "Select processes to KILL (↑↓ move, space toggle, enter confirm):" \
            --selected.foreground 212 \
            --cursor.foreground 212 \
            --selected "${preselect[@]}" 2>/dev/null) || true
    else
        selected=$(printf '%s\n' "${items[@]}" | gum choose --no-limit --height 20 \
            --cursor-prefix "[ ] " --selected-prefix "[✓] " --unselected-prefix "[ ] " \
            --header "Select processes to KILL (↑↓ move, space toggle, enter confirm):" \
            --selected.foreground 212 \
            --cursor.foreground 212 2>/dev/null) || true
    fi

    if [[ -z "$selected" ]]; then
        echo
        gum style --foreground 214 "  No processes selected"
        return 0
    fi

    local count
    count=$(echo "$selected" | wc -l)
    echo
    gum style --foreground 212 --bold "  Selected $count process(es) to terminate"
    echo

    # Show what will be killed with evidence
    gum style --foreground 245 "  Summary of selected:"
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local orig="${pid_map[$line]}"
        IFS=$'\t' read -r score pid ppid age mem cpu tty rec confidence ptype evidence cmd <<< "$orig"
        local evidence_readable="${evidence//|/, }"
        printf "    PID %s: %s\n" "$pid" "${C_DIM}$evidence_readable${C_RESET}"
    done <<< "$selected"
    echo

    # Confirmation
    if ! gum confirm --affirmative "Kill $count" --negative "Cancel" "  Proceed with terminating $count process(es)?"; then
        gum style --foreground 214 "  Cancelled"
        return 0
    fi

    echo
    local killed=0 failed=0

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        local pid
        pid=$(echo "$line" | grep -oE 'PID:[0-9]+' | cut -d: -f2)
        [[ -z "$pid" ]] && continue

        local orig="${pid_map[$line]}"
        local cmd
        cmd=$(echo "$orig" | cut -d$'\t' -f12)

        printf "  Killing PID %s... " "$pid"

        if kill "$pid" 2>/dev/null; then
            echo "${C_SPARE}✓${C_RESET}"
            ((killed++))
        elif kill -9 "$pid" 2>/dev/null; then
            echo "${C_REVIEW}✓ (SIGKILL)${C_RESET}"
            ((killed++))
        else
            echo "${C_KILL}✗ failed${C_RESET}"
            ((failed++))
            continue
        fi

        # Save decision
        local pattern
        pattern=$(normalize_pattern "$cmd")
        save_decision "$pattern" "kill"
    done <<< "$selected"

    # Save spare decisions for unselected
    for line in "${items[@]}"; do
        if ! echo "$selected" | grep -qFx "$line"; then
            local orig="${pid_map[$line]}"
            [[ -z "$orig" ]] && continue
            local cmd
            cmd=$(echo "$orig" | cut -d$'\t' -f12)
            local pattern
            pattern=$(normalize_pattern "$cmd")
            save_decision "$pattern" "spare"
        fi
    done

    echo
    gum style --foreground 82 --bold "  Done! Killed: $killed  Failed: $failed"
    echo
    show_system_stats
    log "Triage complete: killed=$killed failed=$failed"
}

cmd_history() {
    show_header

    if [[ ! -s "$DECISIONS_FILE" ]] || [[ "$(cat "$DECISIONS_FILE")" == "{}" ]]; then
        gum style --foreground 214 "  No decision history yet"
        echo
        gum style --foreground 245 "  Run 'pt' to build up a decision history."
        return 0
    fi

    echo
    local kill_count spare_count
    kill_count=$(jq '[.[] | select(. == "kill")] | length' "$DECISIONS_FILE" 2>/dev/null || echo 0)
    spare_count=$(jq '[.[] | select(. == "spare")] | length' "$DECISIONS_FILE" 2>/dev/null || echo 0)

    gum style --foreground 245 "  Decision History: ${C_KILL}$kill_count kills${C_RESET} | ${C_SPARE}$spare_count spares${C_RESET}"
    echo

    if command -v jq &>/dev/null; then
        jq -r 'to_entries | sort_by(.value) | .[] |
            if .value == "kill" then "  \u001b[91mKILL\u001b[0m  │ \(.key[0:80])"
            else "  \u001b[92mSPARE\u001b[0m │ \(.key[0:80])" end' \
            "$DECISIONS_FILE" 2>/dev/null | head -30
    else
        cat "$DECISIONS_FILE"
    fi
    echo
}

cmd_clear() {
    show_header

    local count=0
    if [[ -s "$DECISIONS_FILE" ]] && command -v jq &>/dev/null; then
        count=$(jq 'length' "$DECISIONS_FILE" 2>/dev/null || echo 0)
    fi

    echo
    if ((count == 0)); then
        gum style --foreground 214 "  No decision history to clear"
        return 0
    fi

    gum style --foreground 245 "  Found $count saved decisions"
    echo

    if gum confirm --affirmative "Clear" --negative "Keep" "  Clear all decision history?"; then
        echo '{}' > "$DECISIONS_FILE"
        gum style --foreground 82 "  ✓ Decision history cleared"
        log "Decision history cleared"
    else
        gum style --foreground 245 "  Kept existing decisions"
    fi
}

cmd_help() {
    cat << 'EOF'
pt - Process Triage v2.0.0
Bayesian-inspired zombie/abandoned process detection

USAGE
    pt              Interactive mode - scan, select, kill
    pt deep         Deep scan with runtime evidence gathering
    pt scan         Show candidates (quick scan)
    pt scan deep    Show candidates (deep scan)
    pt history      Show past decisions
    pt clear        Clear decision history
    pt robot        Agent/robot plan/explain/apply (JSON/MD output)
    pt agent        Alias for pt robot
    pt help         Show this help

HOW IT WORKS
    pt uses a Bayesian-inspired scoring system that weighs multiple
    evidence sources to estimate the probability a process is abandoned:

    EVIDENCE SOURCES
    ├── Process Type     Test, dev server, agent, shell, daemon
    ├── Age Analysis     Compared to expected lifetime for type
    ├── Orphan Status    PPID=1 indicates orphaned process
    ├── CPU Patterns     Stuck at 99% or idle at 0%
    ├── Memory Usage     High memory + old age
    ├── Command Patterns shell-snapshot, --hot, test runners
    └── Past Decisions   Learns from your kill/spare choices

    DEEP SCAN (slower, more accurate)
    ├── I/O Activity     Is the process reading/writing?
    ├── CPU Progress     Is CPU time accumulating?
    ├── Terminal Status  Is the TTY session still active?
    ├── Child Processes  Are children still running?
    └── Network Status   Any open connections?

    RECOMMENDATIONS
    • KILL   (score ≥60, high confidence) - Pre-selected for killing
    • REVIEW (score 30-59) - Worth investigating
    • SPARE  (score <30) - Probably safe to keep

EXAMPLES
    pt                     # Interactive triage
    pt deep                # Deep scan with evidence gathering
    pt scan                # Quick scan, view only
    pt scan deep           # Deep scan, view only

CONFIG
    ~/.config/process_triage/decisions.json  - Learned decisions
    ~/.config/process_triage/triage.log      - Operation log

EOF
}

# ══════════════════════════════════════════════════════════════════════════════
# Main
# ══════════════════════════════════════════════════════════════════════════════

main() {
    case "${1:-run}" in
        robot|agent)
            ensure_config
            ensure_deps_for_json
            shift || true
            cmd_robot "$@"
            ;;
        run|"")
            ensure_gum
            ensure_config
            cmd_run false
            ;;
        deep)
            ensure_gum
            ensure_config
            cmd_run true
            ;;
        scan)
            ensure_gum
            ensure_config
            if [[ "${2:-}" == "deep" ]]; then
                cmd_scan true
            else
                cmd_scan false
            fi
            ;;
        history)
            ensure_gum
            ensure_config
            cmd_history
            ;;
        clear)
            ensure_gum
            ensure_config
            cmd_clear
            ;;
        help|-h|--help)
            cmd_help
            ;;
        version|-v|--version)
            echo "pt version $VERSION"
            ;;
        *)
            echo "Unknown command: $1"
            echo "Run 'pt help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
